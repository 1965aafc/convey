NUM <- list(value = sum(poor * w), lin = (incvec <= x) * 1)
DEN <- list(value = sum(w), lin = rep(1, length(incvec)))
}
list_all <- list(NUM = NUM, DEN = DEN)
CDF <- contrastinf(quote(NUM/DEN), list_all)
rval <- CDF$value
lin <- CDF$lin
variance <- (SE_lin2(lin, full_design))^2
class(rval) <- "cvystat"
attr(rval, "lin") <- lin
attr(rval, "var") <- variance
attr(rval, "statistic") <- "cdf"
rval
}
search()
ls()
icdf <- function(formula, design, x, compinc = FALSE, ...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
inc <- terms.formula(formula)[[2]]
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
w <- weights(design)
ind <- names(w)
poor <- (incvar <= x) * 1
names(poor) <- ind
#one <- rep(1, length(w))
#names(one) <- ind
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
ncom <- names(weights(full_design))
df_full <- model.frame(full_design)
incvec <- df_full[[as.character(inc)]]
wf<- weights(full_design)
Nf<- sum(wf)
value<- sum(poor*w)/N
lin<-(1/N)*((incvar<=x)-value)
names(lin)<- ind
lin<-complete(lin,ncom)
if (compinc) {
value <- sum((incvec<=x)*wf)
lin<- (1/Nf)*((incvec<=x)-value)
}
rval<- value
variance <- (SE_lin2(lin, full_design))^2
class(rval) <- "cvystat"
attr(rval, "lin") <- lin
attr(rval, "var") <- variance
attr(rval, "statistic") <- "cdf"
rval
}
library(vardpoor)
data(eusilc)
dati = data.frame(1:nrow(eusilc), eusilc)
colnames(dati)[1] <- "IDd"
library(survey)
# create a design object
des_eusilc <- svydesign(ids = ~db040, weights = ~rb050, data = eusilc)
library(convey)
des_eusilc <- convey_prep(des_eusilc)
icdf_eqIncome <-icdf(~eqIncome, design=des_eusilc, 20000,ncom=rownames(eusilc),comp=TRUE)
icdf <- function(formula, design, x, compinc = FALSE, ...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
inc <- terms.formula(formula)[[2]]
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
w <- weights(design)
ind <- names(w)
N<- sum(w)
poor <- (incvar <= x) * 1
names(poor) <- ind
#one <- rep(1, length(w))
#names(one) <- ind
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
ncom <- names(weights(full_design))
df_full <- model.frame(full_design)
incvec <- df_full[[as.character(inc)]]
wf<- weights(full_design)
Nf<- sum(wf)
value<- sum(poor*w)/N
lin<-(1/N)*((incvar<=x)-value)
names(lin)<- ind
lin<-complete(lin,ncom)
if (compinc) {
value <- sum((incvec<=x)*wf)
lin<- (1/Nf)*((incvec<=x)-value)
}
rval<- value
variance <- (SE_lin2(lin, full_design))^2
class(rval) <- "cvystat"
attr(rval, "lin") <- lin
attr(rval, "var") <- variance
attr(rval, "statistic") <- "cdf"
rval
}
icdf_eqIncome <-icdf(~eqIncome, design=des_eusilc, 20000,ncom=rownames(eusilc),comp=TRUE)
icdf_eqIncome
icdf <- function(formula, design, x, compinc = FALSE, ...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
inc <- terms.formula(formula)[[2]]
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
w <- weights(design)
ind <- names(w)
N<- sum(w)
poor <- (incvar <= x) * 1
names(poor) <- ind
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
ncom <- names(weights(full_design))
df_full <- model.frame(full_design)
incvec <- df_full[[as.character(inc)]]
wf<- weights(full_design)
Nf<- sum(wf)
value<- sum(poor*w)/N
lin<-(1/N)*((incvar<=x)-value)
names(lin)<- ind
lin<-complete(lin,ncom)
if (compinc) {
value <- sum((incvec<=x)*wf)/Nf
lin<- (1/Nf)*((incvec<=x)-value)
}
rval<- value
variance <- (SE_lin2(lin, full_design))^2
class(rval) <- "cvystat"
attr(rval, "lin") <- lin
attr(rval, "var") <- variance
attr(rval, "statistic") <- "cdf"
rval
}
icdf_eqIncome <-icdf(~eqIncome, design=des_eusilc, 20000,ncom=rownames(eusilc),comp=TRUE)
icdf_eqIncome
convey:::icdf(~eqIncome, design=des_eusilc, 20000,ncom=rownames(eusilc),comp=TRUE)
icdf_eqIncome <-icdf(~eqIncome, design=des_eusilc, 20000,ncom=rownames(eusilc),comp=TRUE)
icdf_eqIncome <-icdf(~eqIncome, design=des_eusilc, 20000,ncom=rownames(eusilc),comp=TRUE)
icdf_eqIncome
convey:::icdf(~eqIncome, design=des_eusilc, 20000,ncom=rownames(eusilc),comp=TRUE)
cdfdom<- svyby(~eqIncome,by= ~db040, design=des_eusilc, FUN=icdf, x=20000,
deff=FALSE )
cdfdom
svyby(~eqIncome,by= ~db040, design=des_eusilc, FUN=convey:::icdf, x=20000,
deff=FALSE )
source('C:/Users/owner/Desktop/rascunhos convey/linqsr.R')
source('C:/Users/owner/Desktop/rascunhos convey/linqsr.R')
source('C:/Users/owner/Desktop/rascunhos convey/linqsr.R')
source('C:/Users/owner/Desktop/rascunhos convey/linqsr.R')
svyqsr.survey.design <- function(formula, design, alpha = 0.2, comp=TRUE,...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
if( length( attr( terms.formula( formula ) , "term.labels" ) ) > 1 ) stop( "convey package functions currently only support one variable in the `formula=` argument" )
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
inc <- terms.formula(formula)[[2]]
ncom<- names(weights(full_design))
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
w <- weights(design)
ind <- names(w)
alpha1 <- alpha
alpha2 <- 1 - alpha
# Linearization of S20
S20 <- isq(formula = formula, design = design, alpha1)
S20 <- list(value= S20[1], lin=attr(S20,"lin"))
# Linearization of S80
S80 <- isq(formula = formula, design = design, alpha2)
S80 <- list(value= S80[1], lin=attr(S80,"lin"))
names(incvar)<-ind
TOT<- list(value=sum(incvar*w), lin=complete(incvar,ncom))
# LINEARIZED VARIABLE OF THE SHARE RATIO
list_all<- list(TOT=TOT, S20 = S20, S80 = S80)
QSR <- contrastinf( quote((TOT-S80)/S20), list_all)
rval <- QSR$value
lin<- as.vector(QSR$lin)
variance <- (SE_lin2(lin, full_design))^2
colnames( variance ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
names( rval ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
class(rval) <- "cvystat"
attr(rval, "var") <- variance
attr(rval, "statistic") <- "qsr"
rval
}
debugonce(svyqsr.survey.design)
fun_isq<- isq(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
comp=TRUE, compinc = TRUE)
svyqsr.survey.design <- function(formula, design, alpha = 0.2, comp=TRUE,...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
if( length( attr( terms.formula( formula ) , "term.labels" ) ) > 1 ) stop( "convey package functions currently only support one variable in the `formula=` argument" )
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
inc <- terms.formula(formula)[[2]]
ncom<- names(weights(full_design))
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
w <- weights(design)
ind <- names(w)
alpha1 <- alpha
alpha2 <- 1 - alpha
# Linearization of S20
S20 <- isq(formula = formula, design = design, alpha1)
S20 <- list(value= S20[1], lin=attr(S20,"lin"))
# Linearization of S80
S80 <- isq(formula = formula, design = design, alpha2)
S80 <- list(value= S80[1], lin=attr(S80,"lin"))
names(incvar)<-ind
TOT<- list(value=sum(incvar*w), lin=complete(incvar,ncom))
# LINEARIZED VARIABLE OF THE SHARE RATIO
list_all<- list(TOT=TOT, S20 = S20, S80 = S80)
QSR <- contrastinf( quote((TOT-S80)/S20), list_all)
rval <- QSR$value
lin<- as.vector(QSR$lin)
variance <- (SE_lin2(lin, full_design))^2
colnames( variance ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
names( rval ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
class(rval) <- "cvystat"
attr(rval, "var") <- variance
attr(rval, "statistic") <- "qsr"
rval
}
ls()
svyqsr.survey.design(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20)
svyqsr.survey.design(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
compinc=T)
svyqsr.survey.design(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
compinc=T)
args(isq)
args(iqalpha)
svyqsr.survey.design <- function(formula, design, alpha = 0.2, comp=TRUE,...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
if( length( attr( terms.formula( formula ) , "term.labels" ) ) > 1 ) stop( "convey package functions currently only support one variable in the `formula=` argument" )
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
inc <- terms.formula(formula)[[2]]
ncom<- names(weights(full_design))
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
w <- weights(design)
ind <- names(w)
alpha1 <- alpha
alpha2 <- 1 - alpha
# Linearization of S20
S20 <- isq(formula = formula, design = design, alpha1,compinc=TRUE)
S20 <- list(value= S20[1], lin=attr(S20,"lin"))
# Linearization of S80
S80 <- isq(formula = formula, design = design, alpha2,compinc = TRUE)
S80 <- list(value= S80[1], lin=attr(S80,"lin"))
names(incvar)<-ind
TOT<- list(value=sum(incvar*w), lin=complete(incvar,ncom))
# LINEARIZED VARIABLE OF THE SHARE RATIO
list_all<- list(TOT=TOT, S20 = S20, S80 = S80)
QSR <- contrastinf( quote((TOT-S80)/S20), list_all)
rval <- QSR$value
lin<- as.vector(QSR$lin)
variance <- (SE_lin2(lin, full_design))^2
colnames( variance ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
names( rval ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
class(rval) <- "cvystat"
attr(rval, "var") <- variance
attr(rval, "statistic") <- "qsr"
rval
}
svyqsr.survey.design(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
compinc=T)
debugonce(svyqsr.survey.design)
svyqsr.survey.design(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
compinc=T)
fun_iqalpha<-iqalpha(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
comp=TRUE, compinc = TRUE)
str(fun_iqalpha)
str(lin_inf)
iqalpha
isq
fun_iqalpha<-iqalpha(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
comp=TRUE, compinc = TRUE)
fun_iqalpha
SE_lin2(lin_inf,des_eusilc)
fun_iqalpha<-iqalpha(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
comp=TRUE, compinc = FALSE)
fun_iqalpha
densfun(~eqIncome,subset(des_eusilc,db040=='Tyrol'),quant_inf,h=NULL,fun="F")
f_quant1
iqalpha(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
h=NULL, comp=TRUE, compinc = TRUE)
SE_lin2(lin_inf,des_eusilc)
fun_iqalpha<-iqalpha(~eqIncome, subset(des_eusilc,db040=='Tyrol'), alpha = .20,
h=NULL, compinc = TRUE)
fun_iqalpha
debugonce(iqalpha)
fun_iqalpha<-iqalpha(~eqIncome, subset(des_eusilc,db040=='Tyrol'), alpha = .20,
h=NULL, compinc = TRUE)
q_alpha
quant_inf
quant_inf <- survey:::svyquantile(~eqIncome, design = des_eusilc,
quantiles = .2, method = "constant")
quant_inf
quant_inf <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .2, method = "constant")
quant_inf
income <-eusilc$eqIncome
weights<- eusilc$rb050
alpha<-20
quant_inf <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .2, method = "constant")
quant_inf<- as.vector(quant_inf)
quant_sup <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .8, method = "constant")
quant_sup<- as.vector(quant_sup)
ind <- (eusilc$db040=="Tyrol")*1
alpha2 <- 100 - alpha
wght <- weights * ind
v <- weights * income * ind
indinf <- (income <= quant_inf)
indsup <- (income > quant_sup)
num_eu <- sum(v*indsup)/sum(wght[indsup]) # Numerator
den_eu <- sum(v*indinf)/sum(wght[indinf]) # Denominator
num <- sum(v*indsup) # Numerator
den <- sum(v*indinf) # Denominator
QSR <- num/den
QSR_eu <- num_eu/den_eu
#**********************************************************************
#*          LINEARIZATION OF THE INCOME QUANTILE SHARE RATIO          *
#**********************************************************************
#----------------------------------------------
#----- LINEARIZATION OF THE TWO QUANTILES -----
#----------------------------------------------
N <- sum(wght) # Estimated (sub)population size
h <- sqrt((sum(wght*income*income)-sum(wght*income)*sum(wght*income)/sum(wght))/sum(wght))/exp(0.2*log(sum(wght)))
# h=S/N^(1/5)
# 1. Linearization of the bottom quantile
u1 <- (quant_inf-income)/h;
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
f_quant1 <- sum(vect_f1*wght)/(N*h)
lin_inf <- -(1/N)*((income<=quant_inf)-alpha/100)/f_quant1
SE_lin2(lin_inf, des_eusilc)
fun_iqalpha<-iqalpha(~eqIncome, subset(des_eusilc,db040=='Tyrol'), alpha = .20,
h=NULL, compinc = TRUE)
fun_iqalpha
income <-eusilc$eqIncome
weights<- eusilc$rb050
alpha<-20
quant_inf <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .2, method = "constant")
quant_inf<- as.vector(quant_inf)
quant_sup <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .8, method = "constant")
quant_sup<- as.vector(quant_sup)
ind <- (eusilc$db040=="Tyrol")*1
alpha2 <- 100 - alpha
wght <- weights * ind
v <- weights * income * ind
indinf <- (income <= quant_inf)
indsup <- (income > quant_sup)
num_eu <- sum(v*indsup)/sum(wght[indsup]) # Numerator
den_eu <- sum(v*indinf)/sum(wght[indinf]) # Denominator
num <- sum(v*indsup) # Numerator
den <- sum(v*indinf) # Denominator
QSR <- num/den
QSR_eu <- num_eu/den_eu
#**********************************************************************
#*          LINEARIZATION OF THE INCOME QUANTILE SHARE RATIO          *
#**********************************************************************
#----------------------------------------------
#----- LINEARIZATION OF THE TWO QUANTILES -----
#----------------------------------------------
N <- sum(wght) # Estimated (sub)population size
h <- sqrt((sum(wght*income*income)-sum(wght*income)*sum(wght*income)/sum(wght))/sum(wght))/exp(0.2*log(sum(wght)))
# h=S/N^(1/5)
# 1. Linearization of the bottom quantile
u1 <- (quant_inf-income)/h;
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
f_quant1 <- sum(vect_f1*wght)/(N*h)
lin_inf <- -(1/N)*((income<=quant_inf)-alpha/100)/f_quant1
SE_lin2(lin_inf, des_eusilc)
fun_iqalpha
fun_iqalpha<-iqalpha(~eqIncome, subset(des_eusilc,db040=='Tyrol'), alpha = .80,
h=NULL, compinc = TRUE)
fun_iqalpha
quant_sup
# 2. Linearization of the top quantile
u2 <- (quant_sup-income)/h
vect_f2 <- exp(-(u2^2)/2)/sqrt(2*pi)
f_quant2 <- sum(vect_f2*wght)/(N*h)
lin_sup <- -(1/N)*((income<=quant_sup)-alpha2/100)/f_quant2
SE_lin2(lin_sup, des_eusilc)
fun_isq<- isq(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
comp=TRUE, compinc = TRUE)
fun_isq
den
SE_lin2(lin_num, des_eusilc)
SE_lin2(lin_num, lin_den)
SE_lin2(lin_den, des_eusilc)
income <-eusilc$eqIncome
weights<- eusilc$rb050
alpha<-20
quant_inf <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .2, method = "constant")
quant_inf<- as.vector(quant_inf)
quant_sup <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .8, method = "constant")
quant_sup<- as.vector(quant_sup)
ind <- (eusilc$db040=="Tyrol")*1
alpha2 <- 100 - alpha
wght <- weights * ind
v <- weights * income * ind
indinf <- (income <= quant_inf)
indsup <- (income > quant_sup)
num_eu <- sum(v*indsup)/sum(wght[indsup]) # Numerator
den_eu <- sum(v*indinf)/sum(wght[indinf]) # Denominator
num <- sum(v*indsup) # Numerator
den <- sum(v*indinf) # Denominator
QSR <- num/den
QSR_eu <- num_eu/den_eu
#**********************************************************************
#*          LINEARIZATION OF THE INCOME QUANTILE SHARE RATIO          *
#**********************************************************************
#----------------------------------------------
#----- LINEARIZATION OF THE TWO QUANTILES -----
#----------------------------------------------
N <- sum(wght) # Estimated (sub)population size
h <- sqrt((sum(wght*income*income)-sum(wght*income)*sum(wght*income)/sum(wght))/sum(wght))/exp(0.2*log(sum(wght)))
# h=S/N^(1/5)
# 1. Linearization of the bottom quantile
u1 <- (quant_inf-income)/h;
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
f_quant1 <- sum(vect_f1*wght)/(N*h)
lin_inf <- -(1/N)*((income<=quant_inf)-alpha/100)/f_quant1
SE_lin2(lin_inf, des_eusilc)
# 2. Linearization of the top quantile
u2 <- (quant_sup-income)/h
vect_f2 <- exp(-(u2^2)/2)/sqrt(2*pi)
f_quant2 <- sum(vect_f2*wght)/(N*h)
lin_sup <- -(1/N)*((income<=quant_sup)-alpha2/100)/f_quant2
SE_lin2(lin_sup, des_eusilc)
# 3. Linearization of the total income for the top quintile
u3 <- (quant_sup-income)/h
vect_f3 <- exp(-(u3^2)/2)/sqrt(2*pi)
f_quant3 <- sum(vect_f3*v)/h
lin_num <- income-income*(income<=quant_sup)-f_quant3*lin_sup
SE_lin2(lin_num, des_eusilc)
# 4. Linearization of the total income for the bottom quintile
u4 <- (quant_inf-income)/h
vect_f4 <- exp(-(u4^2)/2)/sqrt(2*pi)
f_quant4 <- sum(vect_f4*v)/h
lin_den <- income*(income<=quant_inf)+f_quant4*lin_inf
SE_lin2(lin_den, des_eusilc)
fun_isq<- isq(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
comp=TRUE, compinc = TRUE)
fun_isq
lin <- (den*lin_num-num*lin_den)/(den*den)
SE_lin2(lin, des_eusilc)
svyqsr.survey.design(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
compinc=T)
SE_lin2(lin, des_eusilc)
svyqsr.survey.design <- function(formula, design, alpha = 0.2, comp=TRUE,...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
if( length( attr( terms.formula( formula ) , "term.labels" ) ) > 1 ) stop( "convey package functions currently only support one variable in the `formula=` argument" )
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
inc <- terms.formula(formula)[[2]]
ncom<- names(weights(full_design))
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
df_full<-model.frame(full_design)
incvec<-df_full[[as.character(inc)]]
w <- weights(design)
ind <- names(w)
alpha1 <- alpha
alpha2 <- 1 - alpha
# Linearization of S20
S20 <- isq(formula = formula, design = design, alpha1,compinc=TRUE)
S20 <- list(value= S20[1], lin=attr(S20,"lin"))
# Linearization of S80
S80 <- isq(formula = formula, design = design, alpha2,compinc = TRUE)
S80 <- list(value= S80[1], lin=attr(S80,"lin"))
names(incvar)<-ind
TOT<- list(value=sum(incvar*w), lin=incvec)
# LINEARIZED VARIABLE OF THE SHARE RATIO
list_all<- list(TOT=TOT, S20 = S20, S80 = S80)
QSR <- contrastinf( quote((TOT-S80)/S20), list_all)
rval <- QSR$value
lin<- as.vector(QSR$lin)
variance <- (SE_lin2(lin, full_design))^2
colnames( variance ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
names( rval ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
class(rval) <- "cvystat"
attr(rval, "var") <- variance
attr(rval, "statistic") <- "qsr"
rval
}
svyqsr.survey.design(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
compinc=T)
SE_lin2(lin, des_eusilc)
QSR
