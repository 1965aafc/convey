rval
}
svyqsr.survey.design(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
compinc=T)
debugonce(svyqsr.survey.design)
svyqsr.survey.design(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
compinc=T)
fun_iqalpha<-iqalpha(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
comp=TRUE, compinc = TRUE)
str(fun_iqalpha)
str(lin_inf)
iqalpha
isq
fun_iqalpha<-iqalpha(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
comp=TRUE, compinc = TRUE)
fun_iqalpha
SE_lin2(lin_inf,des_eusilc)
fun_iqalpha<-iqalpha(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
comp=TRUE, compinc = FALSE)
fun_iqalpha
densfun(~eqIncome,subset(des_eusilc,db040=='Tyrol'),quant_inf,h=NULL,fun="F")
f_quant1
iqalpha(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
h=NULL, comp=TRUE, compinc = TRUE)
SE_lin2(lin_inf,des_eusilc)
fun_iqalpha<-iqalpha(~eqIncome, subset(des_eusilc,db040=='Tyrol'), alpha = .20,
h=NULL, compinc = TRUE)
fun_iqalpha
debugonce(iqalpha)
fun_iqalpha<-iqalpha(~eqIncome, subset(des_eusilc,db040=='Tyrol'), alpha = .20,
h=NULL, compinc = TRUE)
q_alpha
quant_inf
quant_inf <- survey:::svyquantile(~eqIncome, design = des_eusilc,
quantiles = .2, method = "constant")
quant_inf
quant_inf <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .2, method = "constant")
quant_inf
income <-eusilc$eqIncome
weights<- eusilc$rb050
alpha<-20
quant_inf <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .2, method = "constant")
quant_inf<- as.vector(quant_inf)
quant_sup <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .8, method = "constant")
quant_sup<- as.vector(quant_sup)
ind <- (eusilc$db040=="Tyrol")*1
alpha2 <- 100 - alpha
wght <- weights * ind
v <- weights * income * ind
indinf <- (income <= quant_inf)
indsup <- (income > quant_sup)
num_eu <- sum(v*indsup)/sum(wght[indsup]) # Numerator
den_eu <- sum(v*indinf)/sum(wght[indinf]) # Denominator
num <- sum(v*indsup) # Numerator
den <- sum(v*indinf) # Denominator
QSR <- num/den
QSR_eu <- num_eu/den_eu
#**********************************************************************
#*          LINEARIZATION OF THE INCOME QUANTILE SHARE RATIO          *
#**********************************************************************
#----------------------------------------------
#----- LINEARIZATION OF THE TWO QUANTILES -----
#----------------------------------------------
N <- sum(wght) # Estimated (sub)population size
h <- sqrt((sum(wght*income*income)-sum(wght*income)*sum(wght*income)/sum(wght))/sum(wght))/exp(0.2*log(sum(wght)))
# h=S/N^(1/5)
# 1. Linearization of the bottom quantile
u1 <- (quant_inf-income)/h;
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
f_quant1 <- sum(vect_f1*wght)/(N*h)
lin_inf <- -(1/N)*((income<=quant_inf)-alpha/100)/f_quant1
SE_lin2(lin_inf, des_eusilc)
fun_iqalpha<-iqalpha(~eqIncome, subset(des_eusilc,db040=='Tyrol'), alpha = .20,
h=NULL, compinc = TRUE)
fun_iqalpha
income <-eusilc$eqIncome
weights<- eusilc$rb050
alpha<-20
quant_inf <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .2, method = "constant")
quant_inf<- as.vector(quant_inf)
quant_sup <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .8, method = "constant")
quant_sup<- as.vector(quant_sup)
ind <- (eusilc$db040=="Tyrol")*1
alpha2 <- 100 - alpha
wght <- weights * ind
v <- weights * income * ind
indinf <- (income <= quant_inf)
indsup <- (income > quant_sup)
num_eu <- sum(v*indsup)/sum(wght[indsup]) # Numerator
den_eu <- sum(v*indinf)/sum(wght[indinf]) # Denominator
num <- sum(v*indsup) # Numerator
den <- sum(v*indinf) # Denominator
QSR <- num/den
QSR_eu <- num_eu/den_eu
#**********************************************************************
#*          LINEARIZATION OF THE INCOME QUANTILE SHARE RATIO          *
#**********************************************************************
#----------------------------------------------
#----- LINEARIZATION OF THE TWO QUANTILES -----
#----------------------------------------------
N <- sum(wght) # Estimated (sub)population size
h <- sqrt((sum(wght*income*income)-sum(wght*income)*sum(wght*income)/sum(wght))/sum(wght))/exp(0.2*log(sum(wght)))
# h=S/N^(1/5)
# 1. Linearization of the bottom quantile
u1 <- (quant_inf-income)/h;
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
f_quant1 <- sum(vect_f1*wght)/(N*h)
lin_inf <- -(1/N)*((income<=quant_inf)-alpha/100)/f_quant1
SE_lin2(lin_inf, des_eusilc)
fun_iqalpha
fun_iqalpha<-iqalpha(~eqIncome, subset(des_eusilc,db040=='Tyrol'), alpha = .80,
h=NULL, compinc = TRUE)
fun_iqalpha
quant_sup
# 2. Linearization of the top quantile
u2 <- (quant_sup-income)/h
vect_f2 <- exp(-(u2^2)/2)/sqrt(2*pi)
f_quant2 <- sum(vect_f2*wght)/(N*h)
lin_sup <- -(1/N)*((income<=quant_sup)-alpha2/100)/f_quant2
SE_lin2(lin_sup, des_eusilc)
fun_isq<- isq(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
comp=TRUE, compinc = TRUE)
fun_isq
den
SE_lin2(lin_num, des_eusilc)
SE_lin2(lin_num, lin_den)
SE_lin2(lin_den, des_eusilc)
income <-eusilc$eqIncome
weights<- eusilc$rb050
alpha<-20
quant_inf <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .2, method = "constant")
quant_inf<- as.vector(quant_inf)
quant_sup <- survey:::svyquantile(~eqIncome,
design = subset(des_eusilc,  db040=='Tyrol' ),  quantiles = .8, method = "constant")
quant_sup<- as.vector(quant_sup)
ind <- (eusilc$db040=="Tyrol")*1
alpha2 <- 100 - alpha
wght <- weights * ind
v <- weights * income * ind
indinf <- (income <= quant_inf)
indsup <- (income > quant_sup)
num_eu <- sum(v*indsup)/sum(wght[indsup]) # Numerator
den_eu <- sum(v*indinf)/sum(wght[indinf]) # Denominator
num <- sum(v*indsup) # Numerator
den <- sum(v*indinf) # Denominator
QSR <- num/den
QSR_eu <- num_eu/den_eu
#**********************************************************************
#*          LINEARIZATION OF THE INCOME QUANTILE SHARE RATIO          *
#**********************************************************************
#----------------------------------------------
#----- LINEARIZATION OF THE TWO QUANTILES -----
#----------------------------------------------
N <- sum(wght) # Estimated (sub)population size
h <- sqrt((sum(wght*income*income)-sum(wght*income)*sum(wght*income)/sum(wght))/sum(wght))/exp(0.2*log(sum(wght)))
# h=S/N^(1/5)
# 1. Linearization of the bottom quantile
u1 <- (quant_inf-income)/h;
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
f_quant1 <- sum(vect_f1*wght)/(N*h)
lin_inf <- -(1/N)*((income<=quant_inf)-alpha/100)/f_quant1
SE_lin2(lin_inf, des_eusilc)
# 2. Linearization of the top quantile
u2 <- (quant_sup-income)/h
vect_f2 <- exp(-(u2^2)/2)/sqrt(2*pi)
f_quant2 <- sum(vect_f2*wght)/(N*h)
lin_sup <- -(1/N)*((income<=quant_sup)-alpha2/100)/f_quant2
SE_lin2(lin_sup, des_eusilc)
# 3. Linearization of the total income for the top quintile
u3 <- (quant_sup-income)/h
vect_f3 <- exp(-(u3^2)/2)/sqrt(2*pi)
f_quant3 <- sum(vect_f3*v)/h
lin_num <- income-income*(income<=quant_sup)-f_quant3*lin_sup
SE_lin2(lin_num, des_eusilc)
# 4. Linearization of the total income for the bottom quintile
u4 <- (quant_inf-income)/h
vect_f4 <- exp(-(u4^2)/2)/sqrt(2*pi)
f_quant4 <- sum(vect_f4*v)/h
lin_den <- income*(income<=quant_inf)+f_quant4*lin_inf
SE_lin2(lin_den, des_eusilc)
fun_isq<- isq(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
comp=TRUE, compinc = TRUE)
fun_isq
lin <- (den*lin_num-num*lin_den)/(den*den)
SE_lin2(lin, des_eusilc)
svyqsr.survey.design(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
compinc=T)
SE_lin2(lin, des_eusilc)
svyqsr.survey.design <- function(formula, design, alpha = 0.2, comp=TRUE,...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
if( length( attr( terms.formula( formula ) , "term.labels" ) ) > 1 ) stop( "convey package functions currently only support one variable in the `formula=` argument" )
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
inc <- terms.formula(formula)[[2]]
ncom<- names(weights(full_design))
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
df_full<-model.frame(full_design)
incvec<-df_full[[as.character(inc)]]
w <- weights(design)
ind <- names(w)
alpha1 <- alpha
alpha2 <- 1 - alpha
# Linearization of S20
S20 <- isq(formula = formula, design = design, alpha1,compinc=TRUE)
S20 <- list(value= S20[1], lin=attr(S20,"lin"))
# Linearization of S80
S80 <- isq(formula = formula, design = design, alpha2,compinc = TRUE)
S80 <- list(value= S80[1], lin=attr(S80,"lin"))
names(incvar)<-ind
TOT<- list(value=sum(incvar*w), lin=incvec)
# LINEARIZED VARIABLE OF THE SHARE RATIO
list_all<- list(TOT=TOT, S20 = S20, S80 = S80)
QSR <- contrastinf( quote((TOT-S80)/S20), list_all)
rval <- QSR$value
lin<- as.vector(QSR$lin)
variance <- (SE_lin2(lin, full_design))^2
colnames( variance ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
names( rval ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
class(rval) <- "cvystat"
attr(rval, "var") <- variance
attr(rval, "statistic") <- "qsr"
rval
}
svyqsr.survey.design(~eqIncome,subset(des_eusilc,db040=='Tyrol' ), alpha = .20,
compinc=T)
SE_lin2(lin, des_eusilc)
QSR
library(vardpoor)
data(eusilc)
dati = data.frame(1:nrow(eusilc), eusilc)
colnames(dati)[1] <- "IDd"
library(survey)
# create a design object
des_eusilc <- svydesign(ids = ~db040, weights = ~rb050, data = eusilc)
library(convey)
des_eusilc <- convey_prep(des_eusilc)
# linearize the indicator arpt: whole sample library vardpoor
dati <- data.frame(IDd = 1:nrow(eusilc), eusilc)
vardpoor_arptw <- linarpt(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = NULL,
dataset = dati, percentage = 60, order_quant = 50)
# show results from vardpoor summary list
vardpoor_arptwl <- list(value = vardpoor_arptw$value, lin = vardpoor_arptw$lin$lin_arpt)
vardpoor_arptw$value
library(convey)
SE_lin2(vardpoor_arptw$lin, des_eusilc)
str(vardpoor_arptw)
SE_lin2(vardpoor_arptw$lin$lin_arpt, des_eusilc)
fun_arptw <- svyarpt(~eqIncome, design = des_eusilc, 0.5, 0.6)
fun_arptw
vardpoor_arptd <- linarpt(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = "db040",
dataset = dati, percentage = 60, order_quant = 50)
str(vardpoor_arptd)
lapply(vardpoor_arptd$lin[2:7],function(t)SE_lin2(t,des_eusilc))
lapply(vardpoor_arptd$lin[[2:7]],function(t) SE_lin2(t,des_eusilc))
str(vardpoor_arptd$lin[[2:7]])
str(vardpoor_arptd$lin[2:7])
lapply(vardpoor_arptd$lin[,-1],function(t) SE_lin2(t,des_eusilc))
str(vardpoor_arptd$lin[,2:7])
lapply(as.data.frame(vardpoor_arptd$lin[,2:7]),function(t) SE_lin2(t,des_eusilc))
str(as.data.frame(vardpoor_arptd$lin[,2:7]))
str(data.frame(vardpoor_arptd$lin))
lapply(data.frame(vardpoor_arptd$lin[,2:7]),function(t) SE_lin2(t,des_eusilc))
str(data.frame(vardpoor_arptd$lin[,2:7]))
str(data.frame(vardpoor_arptd$lin[,2:10]))
str(data.frame(vardpoor_arptd$lin)[,2:10])
sapply(data.frame(vardpoor_arptd$lin)[,2:10],function(t) SE_lin2(t,des_eusilc))
unlist(vardpoor_arptdl$value)
# 1.1.2.2 se estimates
sapply(data.frame(vardpoor_arptd$lin)[,2:10],function(t) SE_lin2(t,des_eusilc))
unlist(SE_lin2(vardpoor_arptdl, des_eusilc))
unlist(vardpoor_arptd$value)
unlist(vardpoor_arptd$value$threshold)
unlist(vardpoor_arptd$value$threshold)
# 1.1.2.2 se estimates
sapply(data.frame(vardpoor_arptd$lin)[,2:10],function(t) SE_lin2(t,des_eusilc))
unlist(SE_lin2(vardpoor_arptdl, des_eusilc))
# library convey
fun_arptd <- svyby(~eqIncome, by = ~db040, design = des_eusilc, FUN = svyarpt, order = 0.5, percent = 0.6, deff = FALSE, keep.names = TRUE)
# show results from library convey 1.2.2.1 point estimates
fun_arptd
vardpoor_arprw$value
vardpoor_arprw <- linarpr(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = NULL,
dataset = dati, percentage = 60, order_quant = 50)
vardpoor_arprw$value
SE_lin2(vardpoor_arprw$lin$lin_arpr, des_eusilc)
fun_arprw <- svyarpr(~eqIncome, des_eusilc, 0.5, 0.6)
# show results from convey 2.2.1.1 point estimate
fun_arprw
vardpoor_arprd <- linarpr(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = "db040",
dataset = dati, percentage = 60, order_quant = 50)
unlist(vardpoor_arprd$value$threshold)
vardpoor_arprd <- linarpr(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = "db040",
dataset = dati, percentage = 60, order_quant = 50)
unlist(vardpoor_arprd$value$threshold)
vardpoor_arprd <- linarpr(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = "db040",
dataset = dati, percentage = 60, order_quant = 50)
unlist(vardpoor_arprd$value$arpr)
sapply(data.frame(vardpoor_arprd$lin)[,2:10],function(t) SE_lin2(t,des_eusilc))
fun_arprd <- svyby(~eqIncome, by = ~db040, design = des_eusilc, FUN = svyarpr, order = 0.5, percent = 0.6,deff = FALSE)
fun_arprd
dati <- data.frame(IDd = 1:nrow(eusilc), eusilc)
vardpoor_rmpgw <- linrmpg(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = NULL,
dataset = dati, percentage = 60, order_quant = 50)
vardpoor_rmpgw$value
SE_lin2(vardpoor_rmpgw$lin$lin_rmpg, des_eusilc)
fun_rmpgw <- svyrmpg(~eqIncome, design = des_eusilc, 0.5, 0.6)
# show results from convey 3.2.1.1 point estimate
fun_rmpgw
vardpoor_rmpgd <- linrmpg(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = "db040",
dataset = dati, percentage = 60, order_quant = 50)
unlist(vardpoor_rmpgd$value$rmpg)
sapply(data.frame(vardpoor_rmpgd$lin)[,2:10],function(t) SE_lin2(t,des_eusilc))
fun_rmpgd <- svyby(~eqIncome, by = ~db040, design = des_eusilc, FUN = svyrmpg, order = 0.5, percent = 0.6, deff = FALSE, keep.names = TRUE)
fun_rmpgd
dati <- data.frame(IDd = 1:nrow(eusilc), eusilc)
vardpoor_qsrw <- linqsr(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = NULL,
dataset = dati, alpha = 20)
vardpoor_qsrw$value
# linearized qsr for whole sample 4.1.1.2 se estimate
SE_lin2(vardpoor_qsrw$lin$lin_qsr, des_eusilc)
fun_qsrw <- svyqsr(~eqIncome, des_eusilc, 0.2)
# show results from convey 4.2.1.1 point estimate
fun_qsrw
vardpoor_qsrd <- linqsr(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = "db040",
dataset = dati, alpha = 20)
unlist(vardpoor_qsrd$value$rmpg)
unlist(vardpoor_qsrd$value$qsr)
unlist(vardpoor_qsrd$value$qsr)
unlist(vardpoor_qsrd$value$QSR)
sapply(data.frame(vardpoor_qsrd$lin)[,2:10],function(t) SE_lin2(t,des_eusilc))
fun_qsrd <- svyby(~eqIncome, by = ~db040, design = des_eusilc, FUN = svyqsr1,
alpha = 0.2, deff = FALSE)
# show results from library convey 4.2.2.1 qsr estimates
fun_qsrd
fun_qsrd <- svyby(~eqIncome, by = ~db040, design = des_eusilc, FUN = svyqsr,
alpha = 0.2, deff = FALSE)
fun_qsrd
svygini.survey.design <- function(formula, design, ncom, comp = TRUE, ...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
if( length( attr( terms.formula( formula ) , "term.labels" ) ) > 1 ) stop( "convey package functions currently only support one variable in the `formula=` argument" )
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
ncom <- names(weights(full_design))
inc <- terms.formula(formula)[[2]]
w <- weights(design)
ind <- names(w)
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
w <- w[order(incvar)]
incvar <- incvar[order(incvar)]
# population size
N <- sum(w)
# total income
Y <- sum(incvar * w)
# cumulative weight
r <- cumsum(w)
# partial weighted function
G <- cumsum(incvar * w)
T2<- list(value=sum(incvar*w), lin=incvar)
T3<- list(value= sum(w), lin=rep(1, length(incvar)))
# get T1
T1val<- sum(r*incvar*w)
T1lin<-  Y - G + incvar * w + r* incvar
T1<- list(value=T1val, lin=T1lin)
list_all<- list(T1 = T1, T2 = T2, T3 = T3)
GINI<- contrastinf(quote((2*T1-T2)/(T2*T3)-1), list_all)
lingini <- as.vector(GINI$lin)
# complete with 0
names(lingini) <- names(w)
if (comp) lingini<-complete(lingini, ncom)
rval <- GINI$value
variance <- (SE_lin2(lingini, full_design))^2
colnames( variance ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
names( rval ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
class(rval) <- "cvystat"
attr(rval, "var") <- variance
attr(rval, "statistic") <- "gini"
attr(rval,"lin")<- lingini
rval
}
dati <- data.frame(IDd = 1:nrow(eusilc), eusilc)
vardpoor_giniw <- lingini(Y = "eqIncome", id = "IDd", weight = "rb050", dataset = dati)
vardpoor_giniw$value
SE_lin2(vardpoor_giniw$lin$lin_gini, des_eusilc)
fun_giniw <- svygini(~eqIncome, des_eusilc)
# show results from convey 1.2.1.1 point estimate
fun_giniw
vardpoor_ginid <- lingini(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = c("db040"),    dataset = dati)
vardpoor_ginid <- lingini(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = c("db040"),    dataset = dati)
unlist(vardpoor_ginid$value$Gini)
sapply(data.frame(vardpoor_ginid$lin)[,2:10],function(t) SE_lin2(t,des_eusilc))
fun_ginid <- svyby(~eqIncome, by = ~db040, design = des_eusilc, FUN = svygini, deff = FALSE)
fun_ginid
source('~/GitHub/convey/tests.R')
source('~/GitHub/convey/tests.R')
source('~/GitHub/convey/tests.R')
devtools::document()
devtools::document()
devtools::document()
devtools::test()
devtools::test()
devtools::test()
devtools::document()
devtools::test()
devtools::test()
library(vardpoor)
data(eusilc)
library(survey)
des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
des_eusilc <- convey_prep( des_eusilc )
icdf_eqIncome <-icdf(~eqIncome, design=des_eusilc, 20000)
@export
class(icdf_eqIncome)
str(icdf_eqIncome)
icdf_eqIncome[1,1]
icdf_eqIncome[1]
length(icdf_eqIncome)
length(attr(icdf_eqIncome,"lin"))
devtools::test()
args(icdf)
devtools::test()
devtools::test()
devtools::test()
set.seed(1)
Y<- rchisq(10,3)
H<- rep("str1",10)
PSU<-1:10
w<- rep(2,10)
test<- data.frame(Y=Y, H=H, PSU=PSU, w=w)
des<- survey:::svydesign(id=~PSU, strata = ~H, weights=w, data=test)
des <- convey_prep( des )
a<-icdf(~Y, des, 10, comp=TRUE)
length(attr(a,"lin"))
attr(a,"lin")
a
args(icdf)
a<-icdf(~Y, des, 10)
a
str(a)
a<-icdf(~Y, des, 4)
str(a)
library(vardpoor)
data(eusilc)
library(survey)
des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
des_eusilc <- convey_prep( des_eusilc )
icdf_eqIncome <-icdf(~eqIncome, design=des_eusilc, 20000)
str(icdf_eqIncome)
str<-icdf(~Y, des, 10)
a<-icdf(~Y, des, 10)
str(a)
library(convey)
context("cdf values")
set.seed(1)
Y<- rchisq(10,3)
H<- rep("str1",10)
PSU<-1:10
w<- rep(2,10)
test<- data.frame(Y=Y, H=H, PSU=PSU, w=w)
des<- survey:::svydesign(id=~PSU, strata = ~H, weights=w, data=test)
des <- convey_prep( des )
a<- densfun(~Y, des, x=3, fun="F")
a
library(convey)
set.seed(1)
Y<- rchisq(10,3)
H<- rep("str1",10)
PSU<-1:10
w<- rep(2,10)
test<- data.frame(Y=Y, H=H, PSU=PSU, w=w)
des<- survey:::svydesign(id=~PSU, strata = ~H, weights=w, data=test)
des <- convey_prep( des )
a<-icdf(~Y, des, 10)
test_that("out components", {
expect_is(a,"cvystat")
expect_equal(length(a),1)
expect_is(a[1],"numeric")
expect_is(length(attr(a,"lin")),nrow(test))
expect_named(attr(a,"lin"))
expect_less_than(a[1],1)
expect_more_than(a[1],0)
})
a
debugonce(icdf)
a<-icdf(~Y, des, 10)
df
df
weights
N
ind
names(weights(des))
rownames(test)<- as.character(1:nrow(test))
des<- survey:::svydesign(id=~PSU, strata = ~H, weights=w, data=test)
des <- convey_prep( des )
names(weights(des))
rownames(test)
rownames(test)<- as.character(1:nrow(test))
des <- survey:::svydesign(id=~PSU, strata = ~H, weights=w, data=test)
names(weights(des))
