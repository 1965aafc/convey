lin<- percent*attr(linqalpha,"lin")
full_design <- attr( design , "full_design" )
ncom<-names(weights(full_design))
#names(lin) <- ind
#if (comp) lin <- complete(lin, ncom)
variance <- ( SE_lin2( lin , full_design ) )^2
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr( rval , "statistic" ) <- "arpt"
attr(rval, "lin")<- lin
rval
}
isq1 <- function(formula, design, alpha, comp=TRUE, ...) {
if( is.null( attr( design , "full_design" ) ) ) stop( "you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function." )
inc <- terms.formula(formula)[[2]]
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
w <- weights(design)
ind <- names(w)
full_design <- attr( design , "full_design" )
ncom<- names(weights(full_design))
df_full <- model.frame(full_design)
incvec <- df_full[[as.character(inc)]]
h <- h_fun(incvec, weights(full_design))
QALPHA <- iqalpha1(formula = formula, design = design, alpha, comp=TRUE,
compinc=TRUE)
q_alpha <- QALPHA[1]
iq <- attr(QALPHA, "lin")
inc_inf <- (incvar <= q_alpha) * incvar
tot <- sum(inc_inf * w)
Fprime <- densfun(formula = formula, design = design, q_alpha, htot = h, fun = "S")
isqalpha <- incvec * ((incvec <= q_alpha)) + Fprime * iq
# names(isqalpha)<- ind
# if(comp)isqalpha<-complete(isqalpha, ncom)
rval <- tot
variance <- ( SE_lin2( isqalpha , full_design ) )^2
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr( rval , "statistic" ) <- "isq"
attr(rval, "lin")<- isqalpha
rval
}
fun_arprw_new <-svyarpr1(~eqIncome, des_eusilc, .5, .6)
library(vardpoor)
data(eusilc)
library(survey)
des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
des_eusilc <- convey_prep( des_eusilc )
library(convey)
des_eusilc <- convey_prep( des_eusilc )
arpr_eqIncome<- svyarpr(~eqIncome, design=des_eusilc, .5, .6, comp=TRUE)
arpr_eqIncome
icdf_eqIncome <-icdf(~eqIncome, design=des_eusilc, 20000)
icdf_eqIncome
iqalpha_eqIncome <-iqalpha(~eqIncome, design=des_eusilc, .50 )
iqalpha_eqIncome
des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
isq_eqIncome <-isq(~eqIncome, design=des_eusilc, .20)
des_eusilc <- convey_prep( des_eusilc )
isq_eqIncome <-isq(~eqIncome, design=des_eusilc, .20)
svygpg1 <- function(x, design, sex, comp=TRUE,...) {
if( is.null( attr( design , "full_design" ) ) ) stop( "you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function." )
wage <- terms.formula(x)[[2]]
df <- model.frame(design)
wage <- df[[as.character(wage)]]
w<- weights(design)
ind<-names(w)
full_design <- attr( design , "full_design" )
ncom<-names(weights(full_design))
# sex factor
mf <- model.frame(sex, design$variables, na.action = na.pass)
xx <- lapply(attr(terms(sex), "variables")[-1], function(tt) model.matrix(eval(bquote(~0 +
.(tt))), mf))
cols <- sapply(xx, NCOL)
sex <- matrix(nrow = NROW(xx[[1]]), ncol = sum(cols))
scols <- c(0, cumsum(cols))
for (i in 1:length(xx)) {
sex[, scols[i] + 1:cols[i]] <- xx[[i]]
}
colnames(sex) <- do.call("c", lapply(xx, colnames))
sex <- as.matrix(sex)
col_female <- grep("female", colnames(sex))
col_male <- setdiff(1:2, col_female)
# create linearization objects of totals
INDM <-list(value = sum(sex[, col_male]*w), lin=sex[, col_male])
INDF <- list(value = sum(sex[, col_female]*w), lin=sex[, col_female])
TM<- list(value = sum(wage*sex[, col_male]*w), lin=wage*sex[, col_male])
TF<- list(value = sum(wage*sex[, col_female]*w), lin=wage*sex[, col_female])
list_all_tot <-list(INDM=INDM,INDF=INDF,TM=TM,TF=TF)
list_all_totc<-lapply(list_all_tot, function(t){
names(t$lin)<-ind
complete(t,ncom)
})
IGPG<-contrastinf(quote((TM/INDM-TF/INDF)/(TM/INDM)),list_all_totc)
infun<-IGPG$lin
names(infun) <- ind
infuncomp <- complete(infun, ncom)
# if (comp) lin <- infuncomp else lin <- infun
rval <- IGPG$value
variance <- ( SE_lin2( lin , full_design ) )^2
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr( rval , "statistic" ) <- "gpg"
rval
}
debugonce(svygpg1)
ses_gpg <- svygpg1(~earningsHour, des_ses, ~sex, ncom =rownames(ses), comp=FALSE)
data(ses)
debugonce(svygpg1)
ses_gpg <- svygpg1(~earningsHour, des_ses, ~sex, ncom =rownames(ses), comp=FALSE)
library(survey)
library(vardpoor)
library(convey)
data(ses)
des_ses<- svydesign(id=~1, weights=~weights, data=ses,variables=~weights+sex+earningsHour+location)
des_ses <- convey_prep( des_ses )
ses_gpg <- svygpg1(~earningsHour, des_ses, ~sex, ncom =rownames(ses), comp=FALSE)
debugonce(svygpg1)
ses_gpg <- svygpg1(~earningsHour, des_ses, ~sex, ncom =rownames(ses), comp=FALSE)
str(list_all_totc)
svygpg1 <- function(x, design, sex, comp=TRUE,...) {
if( is.null( attr( design , "full_design" ) ) ) stop( "you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function." )
wage <- terms.formula(x)[[2]]
df <- model.frame(design)
wage <- df[[as.character(wage)]]
w<- weights(design)
ind<-names(w)
full_design <- attr( design , "full_design" )
ncom<-names(weights(full_design))
# sex factor
mf <- model.frame(sex, design$variables, na.action = na.pass)
xx <- lapply(attr(terms(sex), "variables")[-1], function(tt) model.matrix(eval(bquote(~0 +
.(tt))), mf))
cols <- sapply(xx, NCOL)
sex <- matrix(nrow = NROW(xx[[1]]), ncol = sum(cols))
scols <- c(0, cumsum(cols))
for (i in 1:length(xx)) {
sex[, scols[i] + 1:cols[i]] <- xx[[i]]
}
colnames(sex) <- do.call("c", lapply(xx, colnames))
sex <- as.matrix(sex)
col_female <- grep("female", colnames(sex))
col_male <- setdiff(1:2, col_female)
# create linearization objects of totals
INDM <-list(value = sum(sex[, col_male]*w), lin=sex[, col_male])
INDF <- list(value = sum(sex[, col_female]*w), lin=sex[, col_female])
TM<- list(value = sum(wage*sex[, col_male]*w), lin=wage*sex[, col_male])
TF<- list(value = sum(wage*sex[, col_female]*w), lin=wage*sex[, col_female])
list_all_tot <-list(INDM=INDM,INDF=INDF,TM=TM,TF=TF)
list_all_totc<-lapply(list_all_tot, function(t){
names(t$lin)<-ind
list(t$value,complete(t,ncom))
})
IGPG<-contrastinf(quote((TM/INDM-TF/INDF)/(TM/INDM)),list_all_totc)
infun<-IGPG$lin
names(infun) <- ind
infuncomp <- complete(infun, ncom)
# if (comp) lin <- infuncomp else lin <- infun
rval <- IGPG$value
variance <- ( SE_lin2( lin , full_design ) )^2
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr( rval , "statistic" ) <- "gpg"
rval
}
debugonce(svygpg1)
ses_gpg <- svygpg1(~earningsHour, des_ses, ~sex, ncom =rownames(ses), comp=FALSE)
str(list_all_tot)
dim(full_design)
str(list_all_totc)
list_all_totc<-lapply(list_all_tot, function(t){
names(t$lin)<-ind
list(valuet$value,lin=iunlist(complete(t,ncom))
})
list_all_totc<-lapply(list_all_tot, function(t){
names(t$lin)<-ind
list(valuet$value,lin=unlist(complete(t,ncom))
})
list_all_totc<-lapply(list_all_tot, function(t){
names(t$lin)<-ind
list(value=t$value,lin=unlist(complete(t,ncom))
})
list_all_totc<-lapply(list_all_tot, function(t){
names(t$lin)<-ind
list(value=t$value,lin=complete(t$lin,ncom)
})
list_all_totc<-lapply(list_all_tot, function(t){
names(t$lin)<-ind
list(value=t$value,lin=complete(t$lin,ncom))
})
str(list_all_totc)
svygpg1 <- function(x, design, sex, comp=TRUE,...) {
if( is.null( attr( design , "full_design" ) ) ) stop( "you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function." )
wage <- terms.formula(x)[[2]]
df <- model.frame(design)
wage <- df[[as.character(wage)]]
w<- weights(design)
ind<-names(w)
full_design <- attr( design , "full_design" )
ncom<-names(weights(full_design))
# sex factor
mf <- model.frame(sex, design$variables, na.action = na.pass)
xx <- lapply(attr(terms(sex), "variables")[-1], function(tt) model.matrix(eval(bquote(~0 +
.(tt))), mf))
cols <- sapply(xx, NCOL)
sex <- matrix(nrow = NROW(xx[[1]]), ncol = sum(cols))
scols <- c(0, cumsum(cols))
for (i in 1:length(xx)) {
sex[, scols[i] + 1:cols[i]] <- xx[[i]]
}
colnames(sex) <- do.call("c", lapply(xx, colnames))
sex <- as.matrix(sex)
col_female <- grep("female", colnames(sex))
col_male <- setdiff(1:2, col_female)
# create linearization objects of totals
INDM <-list(value = sum(sex[, col_male]*w), lin=sex[, col_male])
INDF <- list(value = sum(sex[, col_female]*w), lin=sex[, col_female])
TM<- list(value = sum(wage*sex[, col_male]*w), lin=wage*sex[, col_male])
TF<- list(value = sum(wage*sex[, col_female]*w), lin=wage*sex[, col_female])
list_all_tot <-list(INDM=INDM,INDF=INDF,TM=TM,TF=TF)
list_all_totc<-lapply(list_all_tot, function(t){
names(t$lin)<-ind
list(value=t$value,lin=complete(t$lin,ncom))
})
IGPG<-contrastinf(quote((TM/INDM-TF/INDF)/(TM/INDM)),list_all_totc)
infun<-IGPG$lin
names(infun) <- ind
infuncomp <- complete(infun, ncom)
# if (comp) lin <- infuncomp else lin <- infun
rval <- IGPG$value
variance <- ( SE_lin2( lin , full_design ) )^2
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr( rval , "statistic" ) <- "gpg"
rval
}
ses_gpg<- svygpg(~earningsHour, des_ses, ~sex, ncom =rownames(ses), comp=FALSE)
ses_gpg
gpgdom <- svyby(~earningsHour, by=~location, design = des_ses, FUN=svygpg1,
sex=~sex, ncom = rownames(ses), comp=TRUE, deff=FALSE, keep.var=FALSE)
ses_gpg<- svygpg(~earningsHour, des_ses, ~sex, ncom =rownames(ses), comp=FALSE)
ses_gpg$value
ses_gpg<- svygpg(~earningsHour, des_ses, ~sex, ncom =rownames(ses), comp=FALSE)
ses_gpg<- svygpg(~earningsHour, des_ses, ~sex, ncom =rownames(ses), comp=FALSE)
ses_gpg
ses_gpg <- svygpg1(~earningsHour, des_ses, ~sex, ncom =rownames(ses), comp=FALSE)
ses_gpg <- svygpg1(~earningsHour, des_ses, ~sex, ncom =rownames(ses), comp=FALSE)
svygpg1 <- function(x, design, sex, comp=TRUE,...) {
if( is.null( attr( design , "full_design" ) ) ) stop( "you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function." )
wage <- terms.formula(x)[[2]]
df <- model.frame(design)
wage <- df[[as.character(wage)]]
w<- weights(design)
ind<-names(w)
full_design <- attr( design , "full_design" )
ncom<-names(weights(full_design))
# sex factor
mf <- model.frame(sex, design$variables, na.action = na.pass)
xx <- lapply(attr(terms(sex), "variables")[-1], function(tt) model.matrix(eval(bquote(~0 +
.(tt))), mf))
cols <- sapply(xx, NCOL)
sex <- matrix(nrow = NROW(xx[[1]]), ncol = sum(cols))
scols <- c(0, cumsum(cols))
for (i in 1:length(xx)) {
sex[, scols[i] + 1:cols[i]] <- xx[[i]]
}
colnames(sex) <- do.call("c", lapply(xx, colnames))
sex <- as.matrix(sex)
col_female <- grep("female", colnames(sex))
col_male <- setdiff(1:2, col_female)
# create linearization objects of totals
INDM <-list(value = sum(sex[, col_male]*w), lin=sex[, col_male])
INDF <- list(value = sum(sex[, col_female]*w), lin=sex[, col_female])
TM<- list(value = sum(wage*sex[, col_male]*w), lin=wage*sex[, col_male])
TF<- list(value = sum(wage*sex[, col_female]*w), lin=wage*sex[, col_female])
list_all_tot <-list(INDM=INDM,INDF=INDF,TM=TM,TF=TF)
list_all_totc<-lapply(list_all_tot, function(t){
names(t$lin)<-ind
list(value=t$value,lin=complete(t$lin,ncom))
})
IGPG<-contrastinf(quote((TM/INDM-TF/INDF)/(TM/INDM)),list_all_totc)
infun<-IGPG$lin
#names(infun) <- ind
#infuncomp <- complete(infun, ncom)
# if (comp) lin <- infuncomp else lin <- infun
rval <- IGPG$value
variance <- ( SE_lin2( infun , full_design ) )^2
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr(rval, "lin") <- infun
attr( rval , "statistic" ) <- "gpg"
rval
}
ses_gpg <- svygpg1(~earningsHour, des_ses, ~sex)
ses_gpg
ses_gpg$value
ses_gpg[1]
svygpg1_AT1<- svygpg1(~earningsHour, subset(des_ses, location=="AT1"),~sex )
svygpg1_AT2<- svygpg1(~earningsHour, subset(des_ses, location=="AT2"), ~sex)
svygpg1_AT3<- svygpg1(~earningsHour, subset(des_ses, location=="AT3"), ~sex)
svygpg1_AT1
svygpg1_AT2<- svygpg1(~earningsHour, subset(des_ses, location=="AT2"), ~sex)
svygpg1_AT2
svygpg1_AT3
svygpg1 <- function(x, design, sex, comp=TRUE,...) {
if( is.null( attr( design , "full_design" ) ) ) stop( "you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function." )
wage <- terms.formula(x)[[2]]
df <- model.frame(design)
wage <- df[[as.character(wage)]]
w<- weights(design)
ind<-names(w)
full_design <- attr( design , "full_design" )
ncom<-names(weights(full_design))
# sex factor
mf <- model.frame(sex, design$variables, na.action = na.pass)
xx <- lapply(attr(terms(sex), "variables")[-1], function(tt) model.matrix(eval(bquote(~0 +
.(tt))), mf))
cols <- sapply(xx, NCOL)
sex <- matrix(nrow = NROW(xx[[1]]), ncol = sum(cols))
scols <- c(0, cumsum(cols))
for (i in 1:length(xx)) {
sex[, scols[i] + 1:cols[i]] <- xx[[i]]
}
colnames(sex) <- do.call("c", lapply(xx, colnames))
sex <- as.matrix(sex)
col_female <- grep("female", colnames(sex))
col_male <- setdiff(1:2, col_female)
# create linearization objects of totals
INDM <-list(value = sum(sex[, col_male]*w), lin=sex[, col_male])
INDF <- list(value = sum(sex[, col_female]*w), lin=sex[, col_female])
TM<- list(value = sum(wage*sex[, col_male]*w), lin=wage*sex[, col_male])
TF<- list(value = sum(wage*sex[, col_female]*w), lin=wage*sex[, col_female])
list_all_tot <-list(INDM=INDM,INDF=INDF,TM=TM,TF=TF)
list_all_totc<-lapply(list_all_tot, function(t){
names(t$lin)<-ind
list(value=t$value,lin=complete(t$lin,ncom))
})
IGPG<-contrastinf(quote((TM/INDM-TF/INDF)/(TM/INDM)),list_all_totc)
infun<-IGPG$lin
#names(infun) <- ind
#infuncomp <- complete(infun, ncom)
# if (comp) lin <- infuncomp else lin <- infun
rval <- IGPG$value
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
variance <- ( SE_lin2( infun , full_design ) )^2
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr(rval, "lin") <- infun
attr( rval , "statistic" ) <- "gpg"
rval
}
ses_gpg <- svygpg1(~earningsHour, des_ses, ~sex)
svygpg1_AT1<- svygpg1(~earningsHour, subset(des_ses, location=="AT1"),~sex )
svygpg1_AT2<- svygpg1(~earningsHour, subset(des_ses, location=="AT2"), ~sex)
svygpg1_AT3<- svygpg1(~earningsHour, subset(des_ses, location=="AT3"), ~sex)
set.seed(1)
y<- c(rchisq(10,10),rchisq(10,20))
H<- rep(c('str1','str2'),c(10,10))
PSU<- rep(rep(c(1,2),c(5,5)),2)
weights <- rep(2,20)
# create data frame
testset<- data.frame(y=y,H=H,psu=PSU, w=weights)
testset$sex<- rep(c(1,2),c(10,10))
testset<- transform(testset, sex= factor(sex,labels=c('female','male')))
testset$im<- 1*(testset$sex=='male')
testset$ifm<- 1*(testset$sex=='female')
testset$ym<- testset$y*(testset$sex=='male')
testset$yfm<- testset$y*(testset$sex=='female')
des<- survey::svydesign(id=~psu, strata =~H, weights =~w, data=testset, nest = TRUE )
des <- convey_prep( des )
a <-survey::svytotal(~ym+yfm+im+ifm, des)
survey::svycontrast(a, quote((ym/im-yfm/im)/(ym/im)))
lin_gpg<- svygpg(~y, des, ~sex)
lin_gpg<- svygpg1(~y, des, ~sex)
lin_gpg
svyrmpg
library(convey)
svyrmpg
convey:::svyrmpg
convey:::svyrmpg.survey.design
svyrmpg1 <- function(formula, design, order = 0.5, percent = 0.6, comp, ...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
ncom = names(weights(full_design))
w <- weights(design)
ind <- names(w)
N <- sum(w)
inc <- terms.formula(formula)[[2]]
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
df_full<- model.frame(full_design)
incvec <- df_full[[as.character(inc)]]
wf<- weights(full_design)
ncom <- names(wf)
ARPT <- svyarpt(formula = formula, full_design, order = 0.5, percent = 0.6)
arpt <- ARPT[1]
linarpt <- attr(ARPT, "lin")
arpr <- sum((incvar <= arpt) * w)/N
dsub <- subset(design, subset = (incvar <= arpt))
medp <- survey::svyquantile(x = formula, dsub, 0.5, method = "constant")
medp <- as.vector(medp)
#RMPG <- 1 - (medp/arpt)
h <- h_fun(incvec,wf)
ARPR <- svyarpr(formula=formula, design= design, order, percent)
Fprimemedp <- densfun(formula = formula, design = design, medp, htot = h, fun = "F")
arpr<-ARPR[1]
ifarpr<-attr(ARPR, "lin")
# linearize cdf of medp
ifmedp <- (1/N) * ((incvar <= medp) - 0.5 * arpr)
names(ifmedp) <- names(w)
ifmedp <- complete(ifmedp, ncom)
# linearize median of poor
linmedp <- (0.5 * ifarpr - ifmedp)/Fprimemedp
MEDP<- list(value=medp,lin=linmedp)
ARPT<- list(value = arpt, lin= linarpt)
list_all<- list(ARPT=ARPT, MEDP=MEDP)
# linearize RMPG
RMPG<- contrastinf(quote((ARPT-MEDP)/ARPT), list_all)
rval <- RMPG$value
infun <- unlist( RMPG$lin)
variance <- ( SE_lin2( infun , full_design ) )^2
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr(rval, "lin") <- infun
attr( rval , "statistic" ) <- "rmpg"
rval
}
fun_rmpgw<- svyrmpg(~eqIncome, des_eusilc, .5, .6, h= htot, ncom=rownames(eusilc),
ARPT=fun_arptw)
library(vardpoor)
data(eusilc)
dati = data.frame(1:nrow(eusilc), eusilc)
colnames(dati)[1] <- "IDd"
library(survey)
# create a design object
des_eusilc <- svydesign(ids = ~db040, weights = ~rb050, data = eusilc)
library(convey)
des_eusilc <- convey_prep(des_eusilc)
fun_rmpgw<- svyrmpg(~eqIncome, des_eusilc, .5, .6, h= htot, ncom=rownames(eusilc),
ARPT=fun_arptw)
fun_rmpgw1<- svyrmpg1(~eqIncome, des_eusilc, .5, .6)
fun_rmpgw1
fun_rmpgd<- svyby(~eqIncome, by= ~db040, design=des_eusilc, FUN=svyrmpg1, order = .50, percent =.6, deff=FALSE, keep.var=FALSE)
fun_rmpgd
svyrmpg.survey.design <- function(formula, design, order = 0.5, percent = 0.6, comp, ...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
ncom = names(weights(full_design))
w <- weights(design)
ind <- names(w)
N <- sum(w)
inc <- terms.formula(formula)[[2]]
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
df_full<- model.frame(full_design)
incvec <- df_full[[as.character(inc)]]
wf<- weights(full_design)
ncom <- names(wf)
ARPT <- svyarpt(formula = formula, full_design, order = 0.5, percent = 0.6)
arpt <- ARPT[1]
linarpt <- attr(ARPT, "lin")
arpr <- sum((incvar <= arpt) * w)/N
dsub <- subset(design, subset = (incvar <= arpt))
medp <- survey::svyquantile(x = formula, dsub, 0.5, method = "constant")
medp <- as.vector(medp)
#RMPG <- 1 - (medp/arpt)
h <- h_fun(incvec,wf)
ARPR <- svyarpr(formula=formula, design= design, order, percent)
Fprimemedp <- densfun(formula = formula, design = design, medp, htot = h, fun = "F")
arpr<-ARPR[1]
ifarpr<-attr(ARPR, "lin")
# linearize cdf of medp
ifmedp <- (1/N) * ((incvar <= medp) - 0.5 * arpr)
names(ifmedp) <- names(w)
ifmedp <- complete(ifmedp, ncom)
# linearize median of poor
linmedp <- (0.5 * ifarpr - ifmedp)/Fprimemedp
MEDP<- list(value=medp,lin=linmedp)
ARPT<- list(value = arpt, lin= linarpt)
list_all<- list(ARPT=ARPT, MEDP=MEDP)
# linearize RMPG
RMPG<- contrastinf(quote((ARPT-MEDP)/ARPT), list_all)
rval <- RMPG$value
infun <- unlist( RMPG$lin)
variance <- ( SE_lin2( infun , full_design ) )^2
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr(rval, "lin") <- infun
attr( rval , "statistic" ) <- "rmpg"
rval
}
library(vardpoor)
data(eusilc)
library(survey)
des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
des_eusilc <- convey_prep( des_eusilc )
rmpg_eqIncome <- svyrmpg(~eqIncome, design=des_eusilc, order =.50,
percent = .60)
rmpg_eqIncome
library(convey)
convey:::svyqsr.survey.design
