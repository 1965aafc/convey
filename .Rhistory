Y1 <- eusilc$eqIncome
wght<- eusilc$rb050
order_quants<- 50
age_under_65<- (eusilc$age<65)* 1
quant_under_65 <- svyquantile(~eqIncome, subset(des_eusilc, age<65), .50, method = "constant")
quant_over_65 <- svyquantile(~eqIncome, subset(des_eusilc, age>=65), .50, method = "constant")
indicator <- rep(1, nrow(eusilc))
dom1 <- (age_under_65==1) * indicator
dom2 <- (age_under_65==0) * indicator
# Size of the domains
N1 <- sum(wght * dom1)
N2 <- sum(wght * dom2)
rmir_val <- quant_over_65/quant_under_65  # Estimated relative median income ratio
rmir_val
h <- sqrt((sum(wght*Y1*Y1)-sum(wght*Y1)*sum(wght*Y1)/sum(wght))/sum(wght))/exp(0.2*log(sum(wght)))
h
h_fun(eusilc$eqIncome, eusilc$rb050)
u1 <- (quant_under_65-Y1) * dom1/h
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
f_quant1 <- sum(vect_f1*wght)/(N1*h)   # Estimate of F'(quantile)
lin_quant_under_65 <- -(1/N1)*dom1*((Y1<=quant_under_65)-order_quants/100)/f_quant1  # Linearized variable
lin_quant_under_65 <- -(1/N1)*dom1*((Y1<=quant_under_65)-order_quants/100)/f_quant1  # Linearized variable
length(dom1)
f_quant1
#---- 2. Linearization of the median income of people aged above 65 -----
Y1 <- eusilc$eqIncome
wght<- eusilc$rb050
order_quants<- 50
age_under_65<- (eusilc$age<65)* 1
quant_under_65 <- svyquantile(~eqIncome, subset(des_eusilc, age<65), .50, method = "constant")
quant_under_65<- as.vector(quant_under_65)
quant_over_65 <- svyquantile(~eqIncome, subset(des_eusilc, age>=65), .50, method = "constant")
quant_over_65<- as.vector(quant_over_65)
indicator <- rep(1, nrow(eusilc))
dom1 <- (age_under_65==1) * indicator
dom2 <- (age_under_65==0) * indicator
# Size of the domains
N1 <- sum(wght * dom1)
N2 <- sum(wght * dom2)
rmir_val <- quant_over_65/quant_under_65  # Estimated relative median income ratio
# Bandwith parameter - h=S/N^(1/5) (calculated over the whole population)
h <- sqrt((sum(wght*Y1*Y1)-sum(wght*Y1)*sum(wght*Y1)/sum(wght))/sum(wght))/exp(0.2*log(sum(wght)))
#---- 1. Linearization of the median income of people aged below 65 ----
u1 <- (quant_under_65-Y1) * dom1/h
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
f_quant1 <- sum(vect_f1*wght)/(N1*h)   # Estimate of F'(quantile)
lin_quant_under_65 <- -(1/N1)*dom1*((Y1<=quant_under_65)-order_quants/100)/f_quant1  # Linearized variable
SE_lin2(lin_quant_under_65,des_eusilc)
svyquantile(~eqIncome, subset(des_eusilc, age>= 65), .5, method = "constant")/
iqalpha1
quant_under_65
quant_under_65
iqalpha2
svyrmir <- function(formula, design, age, agelim, order){
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
if( length( attr( terms.formula( formula ) , "term.labels" ) ) > 1 ) stop( "convey package functions currently only support one variable in the `formula=` argument" )
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
inc <- terms.formula(formula)[[2]]
df <- model.frame(design)
ind <- row.names(df)
incvar <- df[[as.character(inc)]]
df_full<- model.frame(full_design)
incvec <- df_full[[as.character(inc)]]
wf<- weights(full_design)
htot<- h_fun(incvec,wf)
age <-terms.formula(age)[[2]]
agevar <- df[[as.character(inc)]]
dsub1 <- subset(design, age < agelim )
iquant1<- iqalpha(formula = formula, design = dsub1, order, h=htot, compinc = TRUE )
dsub2 <- subset(design, age >= agelim )
iquant2<- iqalpha(formula = formula, design = dsub2, order, h=htot, compinc = TRUE )
# linearize ratio of medians
MED1 <- list(value =coef(iquant1) , lin=attr(iquant1, "lin") )
MED2 <- list(value = coef(iquant2), lin=attr(iquant2, "lin") )
list_all<- list(MED1=MED1, MED2=MED2)
RMED <- contrastinf(quote(MED2/MED1),list_all)
rval <- as.vector(RMED$value)
lin <- RMED$lin
variance <- ( SE_lin2( lin , full_design ) )^2
colnames( variance ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
rownames( variance ) <- names( rval ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr(rval, "lin") <- lin
attr( rval , "statistic" ) <- "rmir"
rval
}
rmir_eusilc<- svyrmir(~eqIncome, des_eusilc, age=~age, agelim = 65, order=.50 )
rmir_eusilc
SE_lin2(d$lin$lin_rmir,des_eusilc)
iqalpha2<- iqalpha(~eqIncome, subset(des_eusilc, age < 65), .50, h=htot)
htot<- h_fun(eusilc$eqIncome, eusilc$rb050)
iqalpha1<- iqalpha(~eqIncome, subset(des_eusilc, age>= 65), .50, h=htot)
iqalpha2
iqalpha2<- iqalpha(~eqIncome, subset(des_eusilc, age < 65), .50, h= htot, incomp=TRUE )
iqalpha2
iqalpha2<- iqalpha(~eqIncome, subset(des_eusilc, age < 65), .50, h= htot, comp=FALSE )
iqalpha2<- iqalpha(~eqIncome, subset(des_eusilc, age < 65), .50, h= htot )
iqalpha2
args(iqalpha)
liniq2<- attr(iqalpha2,'lin' )
table(liniq2)
table(lin_quant_under_65)
iqalpha2<- iqalpha(~eqIncome, subset(des_eusilc, age < 65), .50, h= htot,compinc = TRUE )
liniq2<- attr(iqalpha2,'lin' )
table(liniq2)
debugonce(iqalpha)
iqalpha2<- iqalpha(~eqIncome, subset(des_eusilc, age < 65), .50, h=htot)
dim(design)
ind[1:10]
names(w)[1:10]
q_alpha
dim(full_design)
table(iq)
6287+6219
dim(design)
length(iq)
length(ind)
df_full <- model.frame(full_design)
table(iq)
6287+6219
names(iq)[1:100]
ncom[1:100]
length(ncom)
table(lin_quant_under_65)
comp
iqalpha2<- iqalpha(~eqIncome, subset(des_eusilc, age < 65), .50, h= htot,compinc = TRUE )
length(liniq2)
table(liniq2)
7594 +7233
table(liniq2*(eusilc$age<65))
debugonce(iqalpha)
iqalpha2<- iqalpha(~eqIncome, subset(des_eusilc, age < 65), .50, h= htot,compinc = TRUE )
table(iq)
6287+6219
comp
table(iq)
table(iq)
table(lin_quant_under_65)
compinc
table(iq)
compinc
f_quant1
h_fun(eusilc$eqIncome, eusilc$rb050)
args(densfun)
densfun(~eqIncome,subset(des_eusilc, age>= 65),h=htot,f="F" )
densfun(~eqIncome,subset(des_eusilc, age>= 65),h=htot,fun="F" )
densfun(~eqIncome,subset(des_eusilc, age>= 65),quant_under_65,h=htot,fun="F" )
densfun(~eqIncome,des_eusilc,quant_under_65,h=htot,fun="F" )
densfun(~eqIncome,subset(des_eusilc, age< 65),quant_under_65,h=htot,fun="F" )
densfun
debugonce(densfun)
densfun(~eqIncome,subset(des_eusilc, age< 65), quant_under_65, h=htot,fun="F" )
htot
h
length(u)
length(u1)
sum(u1==0)
length(vec_f1)
length(vect_f1)
sum(exp(-(u1^2)/2)==1)
sum(vect_f1==0)
u1 <- (quant_under_65-Y1) * dom1/h
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
f_quant1 <- sum(vect_f1*wght)/(N1*h)   # Estimate of F'(quantile)
sum(vect_f1==0)
exp(0)
u1 <- (quant_under_65-Y1) * dom1/h
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
vect_f1[u1==0]
sum(vect_f1==0)
sum((vect_f1==0)*1)
?which
lixo<- which(exp(-(u1^2)/2)/sqrt(2*pi)==0)
lixo
u1[18]
indage<- (eusilc$age<65)*1
sum(u1==0)
1/sqrt(2*pi)
lixo<- svysmooth(~eqIncome,des_eusilc)
str(lixo)
lixo(2000)
lixo<- svysmooth(~eqIncome,des_eusilc,quantile = .5)
lixo
str(lixo)
library(vardpoor)
data(eusilc)
dati = data.frame(1:nrow(eusilc), eusilc)
colnames(dati)[1] <- "IDd"
library(survey)
# create a design object
des_eusilc <- svydesign(ids = ~db040, weights = ~rb050, data = eusilc)
library(convey)
des_eusilc <- convey_prep(des_eusilc)
densfun(~eqIncome,subset(des_eusilc, age< 65), quant_under_65, h=htot,fun="F" )
htot<- h_fun(eusilc$eqIncome, eusilc$rb050)
densfun(~eqIncome,subset(des_eusilc, age< 65), quant_under_65, h=htot,fun="F" )
quant_under_65 <- svyquantile(~eqIncome, subset(des_eusilc, age<65), .50, method = "constant")
quant_under_65<- as.vector(quant_under_65)
densfun(~eqIncome,subset(des_eusilc, age< 65), quant_under_65, h=htot,fun="F" )
rmirlinCalc <- function(Y1, ids, wght, indicator, order_quants, age_under_65, quant_under_65, quant_over_65) {
Y1 <- eusilc$eqIncome
wght<- eusilc$rb050
order_quants<- 50
age_under_65<- (eusilc$age<65)* 1
quant_under_65 <- svyquantile(~eqIncome, subset(des_eusilc, age<65), .50, method = "constant")
quant_under_65<- as.vector(quant_under_65)
quant_over_65 <- svyquantile(~eqIncome, subset(des_eusilc, age>=65), .50, method = "constant")
quant_over_65<- as.vector(quant_over_65)
indicator <- rep(1, nrow(eusilc))
dom1 <- (age_under_65==1) * indicator
dom2 <- (age_under_65==0) * indicator
# Size of the domains
N1 <- sum(wght * dom1)
N2 <- sum(wght * dom2)
rmir_val <- quant_over_65/quant_under_65  # Estimated relative median income ratio
# Bandwith parameter - h=S/N^(1/5) (calculated over the whole population)
h <- sqrt((sum(wght*Y1*Y1)-sum(wght*Y1)*sum(wght*Y1)/sum(wght))/sum(wght))/exp(0.2*log(sum(wght)))
#---- 1. Linearization of the median income of people aged below 65 ----
u1 <- (quant_under_65-Y1) * dom1/h
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
f_quant1 <- sum(vect_f1*wght)/(N1*h)   # Estimate of F'(quantile)
f_quant1
u1 <- (quant_under_65-Y1) * dom1/h
Y1 <- eusilc$eqIncome
Y1 <- eusilc$eqIncome
wght<- eusilc$rb050
order_quants<- 50
age_under_65<- (eusilc$age<65)* 1
quant_under_65 <- svyquantile(~eqIncome, subset(des_eusilc, age<65), .50, method = "constant")
quant_under_65<- as.vector(quant_under_65)
quant_over_65 <- svyquantile(~eqIncome, subset(des_eusilc, age>=65), .50, method = "constant")
quant_over_65<- as.vector(quant_over_65)
indicator <- rep(1, nrow(eusilc))
dom1 <- (age_under_65==1) * indicator
dom2 <- (age_under_65==0) * indicator
# Size of the domains
N1 <- sum(wght * dom1)
N2 <- sum(wght * dom2)
rmir_val <- quant_over_65/quant_under_65  # Estimated relative median income ratio
# Bandwith parameter - h=S/N^(1/5) (calculated over the whole population)
h <- sqrt((sum(wght*Y1*Y1)-sum(wght*Y1)*sum(wght*Y1)/sum(wght))/sum(wght))/exp(0.2*log(sum(wght)))
#---- 1. Linearization of the median income of people aged below 65 ----
u1 <- (quant_under_65-Y1) * dom1/h
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
f_quant1 <- sum(vect_f1*wght)/(N1*h)   # Estimate of F'(quantile)
f_quant1
f_quant1 <- sum(vect_f1*wght)/(N1*h)   # Estimate of F'(quantile)
f_quant1
u1 <- (quant_under_65-Y1)/h
vect_f1 <- dom1*exp(-(u1^2)/2)/sqrt(2*pi)
f_quant1 <- sum(vect_f1*wght)/(N1*h)   # Estimate of F'(quantile)
f_quant1
lin_quant_under_65 <- -(1/N1)*dom1*((Y1<=quant_under_65)-order_quants/100)/f_quant1  # Linearized variable
SE_lin2(lin_quant_under_65,des_eusilc)
table(lin_quant_under_65)
iqalpha1<- iqalpha(~eqIncome, subset(des_eusilc, age>= 65), .50, h=htot)
iqalpha1
iqalpha2<- iqalpha(~eqIncome, subset(des_eusilc, age < 65), .50, h= htot,compinc = TRUE )
iqalpha2
iqalpha2<- iqalpha(~eqIncome, subset(des_eusilc, age < 65), .50, h= htot,compinc = TRUE )
iqalpha2<- iqalpha(~eqIncome, subset(des_eusilc, age < 65), .50, h= htot )
iqalpha2
u1 <- (quant_under_65-Y1)/h
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
f_quant1 <- sum(dom1*vect_f1*wght)/(N1*h)
f_quant1
u2 <- (quant_over_65-Y1) /h
vect_f2 <- exp(-(u2^2)/2)/sqrt(2*pi)
f_quant2 <- sum(dom2*vect_f2*wght)/(N2*h)   # Estimate of F'(quantile)
u2 <- (quant_over_65-Y1) /h
vect_f2 <- exp(-(u2^2)/2)/sqrt(2*pi)
f_quant2 <- sum(dom2*vect_f2*wght)/(N2*h)   # Estimate of F'(quantile)
lin_quant_over_65 <- -(1/N2)*dom2*((Y1<=quant_over_65)-order_quants/100)/f_quant2  # Linearized variable
SE_lin2(lin_quant_over_65,des_eusilc)
table(lin_quant_over_65)
iqalpha1<- iqalpha(~eqIncome, subset(des_eusilc, age>= 65), .50, h=htot)
iqalpha1
lin <- (quant_under_65 * lin_quant_over_65 - quant_over_65 * lin_quant_under_65)/(quant_under_65*quant_under_65)
SE_lin2(lin,des_eusilc)
rmir_eusilc<- svyrmir(~eqIncome, des_eusilc, age=~age, agelim = 65, order=.50 )
svyrmir <- function(formula, design, age, agelim, order){
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
if( length( attr( terms.formula( formula ) , "term.labels" ) ) > 1 ) stop( "convey package functions currently only support one variable in the `formula=` argument" )
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
inc <- terms.formula(formula)[[2]]
df <- model.frame(design)
ind <- row.names(df)
incvar <- df[[as.character(inc)]]
df_full<- model.frame(full_design)
incvec <- df_full[[as.character(inc)]]
wf<- weights(full_design)
htot<- h_fun(incvec,wf)
age <-terms.formula(age)[[2]]
agevar <- df[[as.character(inc)]]
dsub1 <- subset(design, age < agelim )
iquant1<- iqalpha(formula = formula, design = dsub1, order, h=htot,  compinc = TRUE )
dsub2 <- subset(design, age >= agelim )
iquant2<- iqalpha(formula = formula, design = dsub2, order, h=htot, compinc = TRUE )
# linearize ratio of medians
MED1 <- list(value =coef(iquant1) , lin=attr(iquant1, "lin") )
MED2 <- list(value = coef(iquant2), lin=attr(iquant2, "lin") )
list_all<- list(MED1=MED1, MED2=MED2)
RMED <- contrastinf(quote(MED2/MED1),list_all)
rval <- as.vector(RMED$value)
lin <- RMED$lin
variance <- ( SE_lin2( lin , full_design ) )^2
colnames( variance ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
rownames( variance ) <- names( rval ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr(rval, "lin") <- lin
attr( rval , "statistic" ) <- "rmir"
rval
}
rmir_eusilc<- svyrmir(~eqIncome, des_eusilc, age=~age, agelim = 65, order=.50 )
rmir_eusilc
SE_lin2(lin,des_eusilc)
u1 <- (quant_under_65-Y1)/h
vect_f1 <- exp(-(u1^2)/2)/sqrt(2*pi)
# estimate the mean of vect_f1 in the domain
f_quant1 <- sum(dom1*vect_f1*wght)/(N1*h)   # Estimate of F'(quantile)
lin_quant_under_65 <- -(1/N1)*dom1*((Y1<=quant_under_65)-order_quants/100)/f_quant1  # Linearized variable
u2 <- (quant_over_65-Y1) /h
vect_f2 <- exp(-(u2^2)/2)/sqrt(2*pi)
# estimate the mean of vect_f2 in the domain
f_quant2 <- sum(dom2*vect_f2*wght)/(N2*h)   # Estimate of F'(quantile)
lin_quant_over_65 <- -(1/N2)*dom2*((Y1<=quant_over_65)-order_quants/100)/f_quant2  # Linearized variable
lin <- (quant_under_65 * lin_quant_over_65 - quant_over_65 * lin_quant_under_65)/(quant_under_65*quant_under_65)
SE_lin2(lin,des_eusilc)
rmir_eusilc<- svyrmir(~eqIncome, des_eusilc, age=~age, agelim = 65, order=.50 )
rmir_eusilc
liniq2<- attr(iqalpha2,'lin' )
table(liniq2)
table(lin_quant_under_65)
table(lin_quant_over_65)
table(attr(iqalpha1,"lin"))
svyrmir <- function(formula, design, age, agelim, order){
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
if( length( attr( terms.formula( formula ) , "term.labels" ) ) > 1 ) stop( "convey package functions currently only support one variable in the `formula=` argument" )
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
inc <- terms.formula(formula)[[2]]
df <- model.frame(design)
ind <- row.names(df)
incvar <- df[[as.character(inc)]]
df_full<- model.frame(full_design)
incvec <- df_full[[as.character(inc)]]
wf<- weights(full_design)
htot<- h_fun(incvec,wf)
age <-terms.formula(age)[[2]]
agevar <- df[[as.character(inc)]]
dsub1 <- subset(design, age < agelim )
iquant1<- iqalpha(formula = formula, design = dsub1, order, h=htot )
dsub2 <- subset(design, age >= agelim )
iquant2<- iqalpha(formula = formula, design = dsub2, order, h=htot )
# linearize ratio of medians
MED1 <- list(value =coef(iquant1) , lin=attr(iquant1, "lin") )
MED2 <- list(value = coef(iquant2), lin=attr(iquant2, "lin") )
list_all<- list(MED1=MED1, MED2=MED2)
RMED <- contrastinf(quote(MED2/MED1),list_all)
rval <- as.vector(RMED$value)
lin <- RMED$lin
variance <- ( SE_lin2( lin , full_design ) )^2
colnames( variance ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
rownames( variance ) <- names( rval ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr(rval, "lin") <- lin
attr( rval , "statistic" ) <- "rmir"
rval
}
rmir_eusilc<- svyrmir(~eqIncome, des_eusilc, age=~age, agelim = 65, order=.50 )
rmir_eusilc
SE_lin2(lin,des_eusilc)
devtools::document()
library("convey", lib.loc="~/R/win-library/3.2")
devtools::document()
convey:::svyrmpg.survey.design
svyrmpg1 <- function(formula, design, order = 0.5, percent = 0.6, comp, ...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
if( length( attr( terms.formula( formula ) , "term.labels" ) ) > 1 ) stop( "convey package functions currently only support one variable in the `formula=` argument" )
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
#     full_design <- design else full_design <- attr(design, "full_design")
#     df_full <- model.frame(full_design)
#     ncom = row.names(df_full)
#     w <- weights(design)
#     N <- sum(w)
#     inc <- terms.formula(formula)[[2]]
#     df <- model.frame(design)
#     ind <- row.names(df)
#     incvar <- df[[as.character(inc)]]
#     df_full<- model.frame(full_design)
#     incvec <- df_full[[as.character(inc)]]
#     wf<- weights(full_design)
ARPT <- svyarpt(formula = formula, full_design, order = 0.5, percent = 0.6)
arpt <- coef(ARPT)
linarpt <- attr(ARPT, "lin")
#     dsub <- subset(design, subset = (incvar <= arpt))
#     medp <- survey::svyquantile(x = formula, dsub, 0.5, method = "constant")
POORMED <- svypoormed(formula = formula, design = design, order = order, percent = percent)
medp <- coef(POORMED)
linmedp <- attr(POORMED, "lin")
#RMPG <- 1 - (medp/arpt)
#     htot <- h_fun(incvec,wf)
#     ARPR <- svyarpr(formula=formula, design= design, order, percent)
#     Fprimemedp <- densfun(formula = formula, design = design, medp,
#       h = htot, fun = "F")
#     arpr<-ARPR[1]
#     ifarpr<-attr(ARPR, "lin")
#     # linearize cdf of medp
#     ifmedp <- (1/N) * ((incvar <= medp) - 0.5 * arpr)
#     names(ifmedp) <- ind
#     ifmedp <- complete(ifmedp, ncom)
#     # linearize median of poor
#     linmedp <- (0.5 * ifarpr - ifmedp)/Fprimemedp
MEDP<- list(value=medp,lin=linmedp)
ARPT<- list(value = arpt, lin= linarpt)
list_all<- list(ARPT=ARPT, MEDP=MEDP)
# linearize RMPG
RMPG<- contrastinf(quote((ARPT-MEDP)/ARPT), list_all)
rval <- RMPG$value
infun <- unlist( RMPG$lin)
variance <- ( SE_lin2( infun , full_design ) )^2
colnames( variance ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
rownames( variance ) <- names( rval ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr(rval, "lin") <- infun
attr( rval , "statistic" ) <- "rmpg"
rval
}
fun_rmpgw<- svyrmpg1(~eqIncome, des_eusilc, .5, .6)
svyrmpg1 <- function(formula, design, order = 0.5, percent = 0.6, comp, ...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
if( length( attr( terms.formula( formula ) , "term.labels" ) ) > 1 ) stop( "convey package functions currently only support one variable in the `formula=` argument" )
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
#     df_full <- model.frame(full_design)
#     ncom = row.names(df_full)
#     w <- weights(design)
#     N <- sum(w)
#     inc <- terms.formula(formula)[[2]]
#     df <- model.frame(design)
#     ind <- row.names(df)
#     incvar <- df[[as.character(inc)]]
#     df_full<- model.frame(full_design)
#     incvec <- df_full[[as.character(inc)]]
#     wf<- weights(full_design)
ARPT <- svyarpt(formula = formula, full_design, order = 0.5, percent = 0.6)
arpt <- coef(ARPT)
linarpt <- attr(ARPT, "lin")
#     dsub <- subset(design, subset = (incvar <= arpt))
#     medp <- survey::svyquantile(x = formula, dsub, 0.5, method = "constant")
POORMED <- svypoormed(formula = formula, design = design, order = order, percent = percent)
medp <- coef(POORMED)
linmedp <- attr(POORMED, "lin")
#RMPG <- 1 - (medp/arpt)
#     htot <- h_fun(incvec,wf)
#     ARPR <- svyarpr(formula=formula, design= design, order, percent)
#     Fprimemedp <- densfun(formula = formula, design = design, medp,
#       h = htot, fun = "F")
#     arpr<-ARPR[1]
#     ifarpr<-attr(ARPR, "lin")
#     # linearize cdf of medp
#     ifmedp <- (1/N) * ((incvar <= medp) - 0.5 * arpr)
#     names(ifmedp) <- ind
#     ifmedp <- complete(ifmedp, ncom)
#     # linearize median of poor
#     linmedp <- (0.5 * ifarpr - ifmedp)/Fprimemedp
MEDP<- list(value=medp,lin=linmedp)
ARPT<- list(value = arpt, lin= linarpt)
list_all<- list(ARPT=ARPT, MEDP=MEDP)
# linearize RMPG
RMPG<- contrastinf(quote((ARPT-MEDP)/ARPT), list_all)
rval <- RMPG$value
infun <- unlist( RMPG$lin)
variance <- ( SE_lin2( infun , full_design ) )^2
colnames( variance ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
rownames( variance ) <- names( rval ) <- strsplit( as.character( formula )[[2]] , ' \\+ ' )[[1]]
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr(rval, "lin") <- infun
attr( rval , "statistic" ) <- "rmpg"
rval
}
fun_rmpgw<- svyrmpg1(~eqIncome, des_eusilc, .5, .6)
fun_rmpgw
fun_rmpgd<- svyby(~eqIncome, by= ~db040, design=des_eusilc, FUN=svyrmpg1, order = .50, percent =.6, deff=FALSE, keep.var=FALSE)
fun_rmpgd
fun_rmpgd<- svyby(~eqIncome, by= ~db040, design=des_eusilc, FUN=svyrmpg1, order = .50, percent =.6, deff=FALSE)
fun_rmpgd
svyrmpg(~eqIncome, des_eusilc, .5, .6)
svyby(~eqIncome, by= ~db040, design=des_eusilc, FUN=svyrmpg, order = .50, percent =.6, deff=FALSE)
devtools::document()
