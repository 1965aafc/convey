names(t$lin)<-ind
list(value=t$value,lin=complete(t$lin,ncom))
})
IGPG<-contrastinf(quote((TM/INDM-TF/INDF)/(TM/INDM)),list_all_totc)
infun<-IGPG$lin
#names(infun) <- ind
#infuncomp <- complete(infun, ncom)
# if (comp) lin <- infuncomp else lin <- infun
rval <- IGPG$value
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
variance <- ( SE_lin2( infun , full_design ) )^2
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr(rval, "lin") <- infun
attr( rval , "statistic" ) <- "gpg"
rval
}
ses_gpg <- svygpg1(~earningsHour, des_ses, ~sex)
svygpg1_AT1<- svygpg1(~earningsHour, subset(des_ses, location=="AT1"),~sex )
svygpg1_AT2<- svygpg1(~earningsHour, subset(des_ses, location=="AT2"), ~sex)
svygpg1_AT3<- svygpg1(~earningsHour, subset(des_ses, location=="AT3"), ~sex)
set.seed(1)
y<- c(rchisq(10,10),rchisq(10,20))
H<- rep(c('str1','str2'),c(10,10))
PSU<- rep(rep(c(1,2),c(5,5)),2)
weights <- rep(2,20)
# create data frame
testset<- data.frame(y=y,H=H,psu=PSU, w=weights)
testset$sex<- rep(c(1,2),c(10,10))
testset<- transform(testset, sex= factor(sex,labels=c('female','male')))
testset$im<- 1*(testset$sex=='male')
testset$ifm<- 1*(testset$sex=='female')
testset$ym<- testset$y*(testset$sex=='male')
testset$yfm<- testset$y*(testset$sex=='female')
des<- survey::svydesign(id=~psu, strata =~H, weights =~w, data=testset, nest = TRUE )
des <- convey_prep( des )
a <-survey::svytotal(~ym+yfm+im+ifm, des)
survey::svycontrast(a, quote((ym/im-yfm/im)/(ym/im)))
lin_gpg<- svygpg(~y, des, ~sex)
lin_gpg<- svygpg1(~y, des, ~sex)
lin_gpg
svyrmpg
library(convey)
svyrmpg
convey:::svyrmpg
convey:::svyrmpg.survey.design
svyrmpg1 <- function(formula, design, order = 0.5, percent = 0.6, comp, ...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
ncom = names(weights(full_design))
w <- weights(design)
ind <- names(w)
N <- sum(w)
inc <- terms.formula(formula)[[2]]
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
df_full<- model.frame(full_design)
incvec <- df_full[[as.character(inc)]]
wf<- weights(full_design)
ncom <- names(wf)
ARPT <- svyarpt(formula = formula, full_design, order = 0.5, percent = 0.6)
arpt <- ARPT[1]
linarpt <- attr(ARPT, "lin")
arpr <- sum((incvar <= arpt) * w)/N
dsub <- subset(design, subset = (incvar <= arpt))
medp <- survey::svyquantile(x = formula, dsub, 0.5, method = "constant")
medp <- as.vector(medp)
#RMPG <- 1 - (medp/arpt)
h <- h_fun(incvec,wf)
ARPR <- svyarpr(formula=formula, design= design, order, percent)
Fprimemedp <- densfun(formula = formula, design = design, medp, htot = h, fun = "F")
arpr<-ARPR[1]
ifarpr<-attr(ARPR, "lin")
# linearize cdf of medp
ifmedp <- (1/N) * ((incvar <= medp) - 0.5 * arpr)
names(ifmedp) <- names(w)
ifmedp <- complete(ifmedp, ncom)
# linearize median of poor
linmedp <- (0.5 * ifarpr - ifmedp)/Fprimemedp
MEDP<- list(value=medp,lin=linmedp)
ARPT<- list(value = arpt, lin= linarpt)
list_all<- list(ARPT=ARPT, MEDP=MEDP)
# linearize RMPG
RMPG<- contrastinf(quote((ARPT-MEDP)/ARPT), list_all)
rval <- RMPG$value
infun <- unlist( RMPG$lin)
variance <- ( SE_lin2( infun , full_design ) )^2
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr(rval, "lin") <- infun
attr( rval , "statistic" ) <- "rmpg"
rval
}
fun_rmpgw<- svyrmpg(~eqIncome, des_eusilc, .5, .6, h= htot, ncom=rownames(eusilc),
ARPT=fun_arptw)
library(vardpoor)
data(eusilc)
dati = data.frame(1:nrow(eusilc), eusilc)
colnames(dati)[1] <- "IDd"
library(survey)
# create a design object
des_eusilc <- svydesign(ids = ~db040, weights = ~rb050, data = eusilc)
library(convey)
des_eusilc <- convey_prep(des_eusilc)
fun_rmpgw<- svyrmpg(~eqIncome, des_eusilc, .5, .6, h= htot, ncom=rownames(eusilc),
ARPT=fun_arptw)
fun_rmpgw1<- svyrmpg1(~eqIncome, des_eusilc, .5, .6)
fun_rmpgw1
fun_rmpgd<- svyby(~eqIncome, by= ~db040, design=des_eusilc, FUN=svyrmpg1, order = .50, percent =.6, deff=FALSE, keep.var=FALSE)
fun_rmpgd
svyrmpg.survey.design <- function(formula, design, order = 0.5, percent = 0.6, comp, ...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
ncom = names(weights(full_design))
w <- weights(design)
ind <- names(w)
N <- sum(w)
inc <- terms.formula(formula)[[2]]
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
df_full<- model.frame(full_design)
incvec <- df_full[[as.character(inc)]]
wf<- weights(full_design)
ncom <- names(wf)
ARPT <- svyarpt(formula = formula, full_design, order = 0.5, percent = 0.6)
arpt <- ARPT[1]
linarpt <- attr(ARPT, "lin")
arpr <- sum((incvar <= arpt) * w)/N
dsub <- subset(design, subset = (incvar <= arpt))
medp <- survey::svyquantile(x = formula, dsub, 0.5, method = "constant")
medp <- as.vector(medp)
#RMPG <- 1 - (medp/arpt)
h <- h_fun(incvec,wf)
ARPR <- svyarpr(formula=formula, design= design, order, percent)
Fprimemedp <- densfun(formula = formula, design = design, medp, htot = h, fun = "F")
arpr<-ARPR[1]
ifarpr<-attr(ARPR, "lin")
# linearize cdf of medp
ifmedp <- (1/N) * ((incvar <= medp) - 0.5 * arpr)
names(ifmedp) <- names(w)
ifmedp <- complete(ifmedp, ncom)
# linearize median of poor
linmedp <- (0.5 * ifarpr - ifmedp)/Fprimemedp
MEDP<- list(value=medp,lin=linmedp)
ARPT<- list(value = arpt, lin= linarpt)
list_all<- list(ARPT=ARPT, MEDP=MEDP)
# linearize RMPG
RMPG<- contrastinf(quote((ARPT-MEDP)/ARPT), list_all)
rval <- RMPG$value
infun <- unlist( RMPG$lin)
variance <- ( SE_lin2( infun , full_design ) )^2
class(rval) <- "cvystat"
attr( rval , "var" ) <- variance
attr(rval, "lin") <- infun
attr( rval , "statistic" ) <- "rmpg"
rval
}
library(vardpoor)
data(eusilc)
library(survey)
des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
des_eusilc <- convey_prep( des_eusilc )
rmpg_eqIncome <- svyrmpg(~eqIncome, design=des_eusilc, order =.50,
percent = .60)
rmpg_eqIncome
library(convey)
convey:::svyqsr.survey.design
library(vardpoor)
data(eusilc)
library(survey)
des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
des_eusilc <- convey_prep( des_eusilc )
library(convey)
des_eusilc <- convey_prep( des_eusilc )
arpr_eqIncome<- svyarpr(~eqIncome, design=des_eusilc, .5, .6, comp=TRUE)
des_eusilc <- convey_prep( des_eusilc )
des_eusilc <- convey_prep( des_eusilc )
arpt_eqIncome <-svyarpt(~eqIncome, design=des_eusilc, .5, .6,comp=TRUE)
arpt_eqIncome
icdf_eqIncome <-icdf(~eqIncome, design=des_eusilc, 20000)
iqalpha_eqIncome <-iqalpha(~eqIncome, design=des_eusilc, .50 )
iqalpha_eqIncome
isq_eqIncome <-isq(~eqIncome, design=des_eusilc, .20)
isq_eqIncome
debugonce(convey:::svyarpt.survey.design)
arpt_eqIncome <-svyarpt(~eqIncome, design=des_eusilc, .5, .6,comp=TRUE)
library(convey)
library(vardpoor)
data(eusilc)
library(survey)
des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
des_eusilc <- convey_prep( des_eusilc )
arpt_eqIncome <-svyarpt(~eqIncome, design=des_eusilc, .5, .6,comp=TRUE)
arpt_eqIncome
arpr_eqIncome<- svyarpr(~eqIncome, design=des_eusilc, .5, .6, comp=TRUE)
arpr_eqIncome
convey:::isq
svyqsr1 <- function(formula, design, alpha = 0.2, comp=TRUE,...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
inc <- terms.formula(formula)[[2]]
ncom<- names(weights(full_design))
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
w <- weights(design)
ind <- names(w)
alpha1 <- alpha
alpha2 <- 1 - alpha
# Linearization of S20
S20 <- isq(formula = formula, design = design, alpha1)
S20 <- list(value= S20[1], lin=attr(S20,"lin"))
# Linearization of S80
S80 <- isq(formula = formula, design = design, alpha2)
S80 <- list(value= S80[1], lin=attr(S80,"lin"))
names(incvar)<-ind
TOT<- list(value=sum(incvar*w), lin=complete(incvar,ncom))
# LINEARIZED VARIABLE OF THE SHARE RATIO
list_all<- list(TOT=TOT, S20 = S20, S80 = S80)
QSR <- contrastinf( quote((TOT-S80)/S20), list_all)
#   lin_qsr <- QSR$lin
#   names(lin_qsr) <- ind
#   lin_qsr_comp <- complete(lin_qsr, ncom)
#   if (comp)
#     lin <- lin_qsr_comp else lin <- lin_qsr
rval <- QSR$value
variance <- (SE_lin2(lin, full_design))^2
class(rval) <- "cvystat"
attr(rval, "var") <- variance
attr(rval, "statistic") <- "qsr"
rval
}
svyqsr1 <- function(formula, design, alpha = 0.2, comp=TRUE,...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
inc <- terms.formula(formula)[[2]]
ncom<- names(weights(full_design))
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
w <- weights(design)
ind <- names(w)
alpha1 <- alpha
alpha2 <- 1 - alpha
# Linearization of S20
S20 <- isq(formula = formula, design = design, alpha1)
S20 <- list(value= S20[1], lin=attr(S20,"lin"))
# Linearization of S80
S80 <- isq(formula = formula, design = design, alpha2)
S80 <- list(value= S80[1], lin=attr(S80,"lin"))
names(incvar)<-ind
TOT<- list(value=sum(incvar*w), lin=complete(incvar,ncom))
# LINEARIZED VARIABLE OF THE SHARE RATIO
list_all<- list(TOT=TOT, S20 = S20, S80 = S80)
QSR <- contrastinf( quote((TOT-S80)/S20), list_all)
#   lin_qsr <- QSR$lin
#   names(lin_qsr) <- ind
#   lin_qsr_comp <- complete(lin_qsr, ncom)
#   if (comp)
#     lin <- lin_qsr_comp else lin <- lin_qsr
rval <- QSR$value
variance <- (SE_lin2(lin, full_design))^2
class(rval) <- "cvystat"
attr(rval, "var") <- variance
attr(rval, "statistic") <- "qsr"
rval
}
fun_qsrw1 <-  svyqsr1(~eqIncome, des_eusilc, .20)
svyqsr1 <- function(formula, design, alpha = 0.2, comp=TRUE,...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
inc <- terms.formula(formula)[[2]]
ncom<- names(weights(full_design))
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
w <- weights(design)
ind <- names(w)
alpha1 <- alpha
alpha2 <- 1 - alpha
# Linearization of S20
S20 <- isq(formula = formula, design = design, alpha1)
S20 <- list(value= S20[1], lin=attr(S20,"lin"))
# Linearization of S80
S80 <- isq(formula = formula, design = design, alpha2)
S80 <- list(value= S80[1], lin=attr(S80,"lin"))
names(incvar)<-ind
TOT<- list(value=sum(incvar*w), lin=complete(incvar,ncom))
# LINEARIZED VARIABLE OF THE SHARE RATIO
list_all<- list(TOT=TOT, S20 = S20, S80 = S80)
QSR <- contrastinf( quote((TOT-S80)/S20), list_all)
#   lin_qsr <- QSR$lin
#   names(lin_qsr) <- ind
#   lin_qsr_comp <- complete(lin_qsr, ncom)
#   if (comp)
#     lin <- lin_qsr_comp else lin <- lin_qsr
rval <- QSR$value
lin<- as.vector(QSR$lin)
variance <- (SE_lin2(lin, full_design))^2
class(rval) <- "cvystat"
attr(rval, "var") <- variance
attr(rval, "statistic") <- "qsr"
rval
}
fun_qsrw1 <-  svyqsr1(~eqIncome, des_eusilc, .20)
fun_qsrw1
fun_qsrd<- svyby(~eqIncome, by= ~db040, design=des_eusilc, FUN=svyqsr1, alpha=.20,
deff=FALSE, keep.var=FALSE)
debugonce(svyqsr1)
fun_qsrd<- svyby(~eqIncome, by= ~db040, design=des_eusilc, FUN=svyqsr1, alpha=.20,
deff=FALSE, keep.var=FALSE)
des_Tyrol<-subset(des_eusilc, db040=="Tyrol")
lixo<-isq(~eqIncome, des_Tyrol, .20, comp=TRUE ) # not working
debugonce(isq)
lixo<-isq(~eqIncome, des_Tyrol, .20, comp=TRUE ) # not working
dim(full_design)
dim(design)
args(iqalpha)
library(convey)
library(vardpoor)
data(eusilc)
dati = data.frame(1:nrow(eusilc), eusilc)
colnames(dati)[1] <- "IDd"
library(survey)
# create a design object
des_eusilc <- svydesign(ids = ~db040, weights = ~rb050, data = eusilc)
library(convey)
des_eusilc <- convey_prep(des_eusilc)
lixo<-isq(~eqIncome, des_Tyrol, .20, comp=TRUE ) # not working
des_Tyrol<-subset(des_eusilc, db040=="Tyrol")
lixo<-isq(~eqIncome, des_Tyrol, .20, comp=TRUE ) # not working
lixo
fun_qsrw1 <-  svyqsr1(~eqIncome, des_eusilc, .20)
svyqsr1 <- function(formula, design, alpha = 0.2, comp=TRUE,...) {
if (is.null(attr(design, "full_design")))
stop("you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function.")
# if the class of the full_design attribute is just a TRUE, then the design is
# already the full design.  otherwise, pull the full_design from that attribute.
if ("logical" %in% class(attr(design, "full_design")))
full_design <- design else full_design <- attr(design, "full_design")
inc <- terms.formula(formula)[[2]]
ncom<- names(weights(full_design))
df <- model.frame(design)
incvar <- df[[as.character(inc)]]
w <- weights(design)
ind <- names(w)
alpha1 <- alpha
alpha2 <- 1 - alpha
# Linearization of S20
S20 <- isq(formula = formula, design = design, alpha1)
S20 <- list(value= S20[1], lin=attr(S20,"lin"))
# Linearization of S80
S80 <- isq(formula = formula, design = design, alpha2)
S80 <- list(value= S80[1], lin=attr(S80,"lin"))
names(incvar)<-ind
TOT<- list(value=sum(incvar*w), lin=complete(incvar,ncom))
# LINEARIZED VARIABLE OF THE SHARE RATIO
list_all<- list(TOT=TOT, S20 = S20, S80 = S80)
QSR <- contrastinf( quote((TOT-S80)/S20), list_all)
#   lin_qsr <- QSR$lin
#   names(lin_qsr) <- ind
#   lin_qsr_comp <- complete(lin_qsr, ncom)
#   if (comp)
#     lin <- lin_qsr_comp else lin <- lin_qsr
rval <- QSR$value
lin<- as.vector(QSR$lin)
variance <- (SE_lin2(lin, full_design))^2
class(rval) <- "cvystat"
attr(rval, "var") <- variance
attr(rval, "statistic") <- "qsr"
rval
}
fun_qsrw1 <-  svyqsr1(~eqIncome, des_eusilc, .20)
fun_qsrw1
fun_qsrd<- svyby(~eqIncome, by= ~db040, design=des_eusilc, FUN=svyqsr1, alpha=.20,
deff=FALSE, keep.var=FALSE)
fun_qsrd
library(convey)
library(vardpoor)
data(eusilc)
library(survey)
des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
des_eusilc <- convey_prep( des_eusilc )
qsr_eqIncome<- svyqsr(~eqIncome, design=des_eusilc, alpha= .20)
qsr_eqIncome
library(convey)
library(vardpoor)
data(eusilc)
library(survey)
des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
des_eusilc <- convey_prep( des_eusilc )
qsr_eqIncome<- svyqsr(~eqIncome, design=des_eusilc, alpha= .20)
qsr_eqIncome
library(vardpoor)
data(eusilc)
dati = data.frame(1:nrow(eusilc), eusilc)
colnames(dati)[1] <- "IDd"
library(survey)
# create a design object
des_eusilc <- svydesign(ids = ~db040, weights = ~rb050, data = eusilc)
library(convey)
des_eusilc <- convey_prep(des_eusilc)
library(convey)
# linearize the indicator arpt: whole sample library vardpoor
dati <- data.frame(IDd = 1:nrow(eusilc), eusilc)
vardpoor_arptw <- linarpt(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = NULL,
dataset = dati, percentage = 60, order_quant = 50)
# show results from vardpoor summary list
vardpoor_arptwl <- list(value = vardpoor_arptw$value, lin = vardpoor_arptw$lin$lin_arpt)
vardpoor_arptw$value
SE_lin(vardpoor_arptwl, des_eusilc)
fun_arptw <- svyarpt(~eqIncome, design = des_eusilc, 0.5, 0.6)
fun_arptw
vardpoor_arptd <- linarpt(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = "db040",
dataset = dati, percentage = 60, order_quant = 50)
# summary list
vardpoor_arptdl <- list(domain = data.frame(vardpoor_arptd$value)[, "db040"], value = as.list(as.data.frame(vardpoor_arptd$value)[,
2]), statistic.lin = as.list(as.data.frame(vardpoor_arptd$lin)[, 2:10]))
# 1.1.2.1 point estimates
unlist(vardpoor_arptdl$value)
# 1.1.2.2 se estimates
unlist(SE_lin(vardpoor_arptdl, des_eusilc))
fun_arptd <- svyby(~eqIncome, by = ~db040, design = des_eusilc, FUN = svyarpt, order = 0.5, percent = 0.6, deff = FALSE, keep.var = FALSE, keep.names = TRUE)
fun_arptd
vardpoor_arprw <- linarpr(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = NULL,
dataset = dati, percentage = 60, order_quant = 50)
# summary list
vardpoor_arprwl <- list(value = vardpoor_arprw$value, lin = vardpoor_arprw$lin$lin_arpr)
# 2.1.1.1 point estimate
vardpoor_arprw$value
# 2.1.1.2 se estimate
SE_lin(vardpoor_arprwl, des_eusilc)
fun_arprw <- svyarpr(~eqIncome, des_eusilc, 0.5, 0.6)
fun_arprw
fun_arprd <- svyby(~eqIncome, by = ~db040, design = des_eusilc, FUN = svyarpr, order = 0.5, percent = 0.6,deff = FALSE, keep.var = FALSE)
fun_arprd
unlist(vardpoor_arprdl$value)
vardpoor_arprd <- linarpr(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = "db040",
dataset = dati, percentage = 60, order_quant = 50)
# summary list
vardpoor_arprdl <- list(domain = data.frame(vardpoor_arprd$value)[, "db040"], value = as.list(as.data.frame(vardpoor_arprd$value)[,
2]), statistic.lin = as.list(as.data.frame(vardpoor_arprd$lin)[, 2:10]))
# 2.1.2.1 point estimates
unlist(vardpoor_arprdl$value)
# 2.1.2.2 se estimates
unlist(SE_lin(vardpoor_arprdl, des_eusilc))
fun_arprd
fun_rmpgw <- svyrmpg(~eqIncome, design = des_eusilc, 0.5, 0.6)
dati <- data.frame(IDd = 1:nrow(eusilc), eusilc)
vardpoor_rmpgw <- linrmpg(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = NULL,
dataset = dati, percentage = 60, order_quant = 50)
# show results from vardpoor summary list
vardpoor_rmpgwl <- list(value = vardpoor_rmpgw$value, lin = vardpoor_rmpgw$lin$lin_rmpg)
# 3.1.1.1 point estimate
vardpoor_rmpgw$value
# linearized rmpg for whole sample 3.1.1.2 se estimate
SE_lin(vardpoor_rmpgwl, des_eusilc)
fun_rmpgw
vardpoor_rmpgd <- linrmpg(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = "db040",
dataset = dati, percentage = 60, order_quant = 50)
# summary list
vardpoor_rmpgdl <- list(domain = data.frame(vardpoor_rmpgd$value)[, "db040"], value = as.list(as.data.frame(vardpoor_rmpgd$value)[,
2]), statistic.lin = as.list(as.data.frame(vardpoor_rmpgd$lin)[, 2:10]))
# 3.1.2.1 point estimates
unlist(vardpoor_rmpgdl$value)
# 3.1.2.2 se estimates
unlist(SE_lin(vardpoor_rmpgdl, des_eusilc))
fun_rmpgd <- svyby(~eqIncome, by = ~db040, design = des_eusilc, FUN = svyrmpg, order = 0.5, percent = 0.6, deff = FALSE, keep.var = FALSE, keep.names = TRUE)
fun_rmpgd
dati <- data.frame(IDd = 1:nrow(eusilc), eusilc)
vardpoor_qsrw <- linqsr(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = NULL,
dataset = dati, alpha = 20)
# show results from vardpoor summary list
vardpoor_qsrwl <- list(value = vardpoor_qsrw$value, lin = vardpoor_qsrw$lin$lin_qsr)
# 4.1.1.1 point estimate
vardpoor_qsrw$value
# linearized qsr for whole sample 4.1.1.2 se estimate
SE_lin(vardpoor_qsrwl, des_eusilc)
fun_qsrw <- svyqsr(~eqIncome, des_eusilc, 0.2)
fun_qsrw
fun_qsrd <- svyby(~eqIncome, by = ~db040, design = des_eusilc, FUN = svyqsr,
alpha = 0.2, deff = FALSE,keep.var = FALSE)
vardpoor_qsrd <- linqsr(Y = "eqIncome", id = "IDd", weight = "rb050", Dom = "db040",
dataset = dati, alpha = 20)
# summary list
vardpoor_qsrdl <- list(domain = data.frame(vardpoor_qsrd$value)[, "db040"], value = as.list(as.data.frame(vardpoor_qsrd$value)[,
2]), statistic.lin = as.list(as.data.frame(vardpoor_qsrd$lin)[, 2:10]))
# 4.1.2.1 point estimates
unlist(vardpoor_qsrdl$value)
# 4.1.2.2 se estimates
unlist(SE_lin(vardpoor_qsrdl, des_eusilc))
fun_qsrd
