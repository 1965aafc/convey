#' Relative median poverty gap
#'
#' Estimate the difference between the poverty threshold (arpt) and the median of  incomes less than the \code{arpt} relative to the \code{arpt}.
#'
#'
#' @param formula a formula specifying the income variable
#' @param design  a design object generated by the function svydesign of
#' the library survey
#' @param order  income quantile order, usually .5
#' @param percent fraction of the quantile, usually .60
#' @param h bandwidth to estimate the derivative of the cdf function
#' @param ARPR list generated by the function svyarpt
#' @param ncom length of the income vector for the whole sample
#' @param comp logical variable \code{TRUE} if the inearized variable for domains
#' should be completed with zeros
#'
#' @return a list with two components: the indicator estimate \code{value}
#' and the linearized variable \code {lin}.
#'
#' @author Djalma Pessoa and Anthony Damico
#' #' @seealso \code{\link{arpt}}
#'
#' @references Guillaume Osier (2009). Variance estimation for complex indicators
#'of poverty and inequality. \emph{Journal of the European Survey Research
#' Association}, Vol.3, No.3, pp. 167-195,
#' ISSN 1864-3361, URL \url{http://ojs.ub.uni-konstanz.de/srm/article/view/369}.

#'Jean-Claude Deville (1999). Variance estimation for complex statistics and estimators: #'linearization and residual techniques. Survey Methodology, 25, 193-203,
#' URL \url{http://www5.statcan.gc.ca/bsolc/olc-cel/olc-cel?lang=eng&catno=12-001-X19990024882}.
#'
#' @keywords survey
#'
#' @examples
#' library(vardpoor)
#' data(eusilc)
#' library(survey)
#' htot <- h_fun(eusilc$eqIncome, eusilc$rb050)
#' des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
#' arpt_eusilc<-svyarpt_lin(~eqIncome, design=des_eusilc, .5, .6, h = htot, ncom=nrow(eusilc), comp=TRUE)
#' arpr_eulsilc<- svyarpr_lin(~eqIncome, design=des_eusilc, .5, .6, h = htot,
#' ARPT = arpt_eusilc, ncom=nrow(eusilc), comp=TRUE)
#'
#' @export

svyqsr <-  function( formula , design , ... ){

  UseMethod( "svyqsr" , design )

}


svyqsr.survey.design <- function(formula, design, alpha= .20, ncom, comp,incvec, ...) {
  inc <- terms.formula(formula)[[2]]
  df <- model.frame(design)
  incvar<-df[[as.character(inc)]]
  w<-weights(design)
  ind<-names(w)
  alpha1<- alpha
  alpha2<- 1-alpha
  quant_inf <-  svyquantile(x = formula, design = design, quantiles = alpha1,
    method = "constant")
  quant_inf<-as.vector(quant_inf)
  quant_sup <- svyquantile(x = formula, design = design, quantiles= alpha2,
    method = "constant")
  quant_sup <- as.vector(quant_sup)
  tot_var<- sum(incvar*w)
  rich<- (incvar > quant_sup)*incvar
  S80 <- sum(rich*w)
  poor<- (incvar <= quant_inf)*incvar
  S20 <- sum(poor*w)
  qsr<- S80/S20
  # Linearization of S20
  lin_S20 <- isq(formula = formula, design = design, alpha1, type="inf", h=NULL,
    ncom= ncom, comp = FALSE, incvec = incvec)$lin
  # Linearization of S80
  lin_S80 <- isq(formula = formula, design = design, alpha2, type="sup", h=NULL,
    ncom= ncom, comp=FALSE, incvec=incvec)$lin

  # LINEARIZED VARIABLE OF THE SHARE RATIO

  lin_qsr<-(S20*lin_S80-S80*lin_S20)/(S20*S20)

  names(lin_qsr)<-ind
  lin_qsr_comp<-complete(lin_qsr, ncom)
  if(comp) lin<-lin_qsr_comp else lin<-lin_qsr
  list(value = qsr, lin = lin_qsr)
}

svyqsr.svyrep.design <- function(formula, design, alpha= .20, ...) {
  inc <- terms.formula(formula)[[2]]
  df <- model.frame(design)
  incvar<-df[[as.character(inc)]]
  w<-weights(design)
  ind<-names(w)
  alpha1<- alpha
  alpha2<- 1-alpha
  quant_inf <-  svyquantile(x = formula, design = design, quantiles = alpha1,
    method = "constant")
  quant_inf<-as.vector(quant_inf)
  quant_sup <- svyquantile(x = formula, design = design, quantiles= alpha2,
    method = "constant")
  quant_sup <- as.vector(quant_sup)
  tot_var<- sum(incvar*w)
  rich<- (incvar > quant_sup)*incvar
  S80 <- sum(rich*w)
  poor<- (incvar <= quant_inf)*incvar
  S20 <- sum(poor*w)
  qsr<- S80/S20
  qsr
}

