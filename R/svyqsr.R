#' Relative median poverty gap
#'
#' Estimate the difference between the poverty threshold (arpt) and the median of  incomes less than the \code{arpt} relative to the \code{arpt}.
#'
#'
#' @param formula a formula specifying the income variable
#' @param design a design object of class \code{survey.design} or class \code{svyrep.design}
#' of the library survey
#' @param order  income quantile order, usually .5
#' @param percent fraction of the quantile, usually .60
#' @param h bandwidth to estimate the derivative of the cdf function
#' @param ARPR list generated by the function svyarpt
#' @param ncom length of the income vector for the whole sample
#' @param comp logical variable \code{TRUE} if the inearized variable for domains
#' should be completed with zeros
#'
#' @return a list with two components: the indicator estimate \code{value}
#' and the linearized variable \code{lin}.
#'
#' @author Djalma Pessoa and Anthony Damico
#' @seealso \code{\link{arpt}}
#'
#' @references Guillaume Osier (2009). Variance estimation for complex indicators
#'of poverty and inequality. \emph{Journal of the European Survey Research
#' Association}, Vol.3, No.3, pp. 167-195,
#' ISSN 1864-3361, URL \url{http://ojs.ub.uni-konstanz.de/srm/article/view/369}.

#'Jean-Claude Deville (1999). Variance estimation for complex statistics and estimators:
#'linearization and residual techniques. Survey Methodology, 25, 193-203,
#' URL \url{http://www5.statcan.gc.ca/bsolc/olc-cel/olc-cel?lang=eng&catno=12-001-X19990024882}.
#'
#' @keywords survey
#'
#' @examples
#' library(vardpoor)
#' data(eusilc)
#' library(survey)
#' htot <- h_fun(eusilc$eqIncome, eusilc$rb050)
#' des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
#' qsr_eqIncome<- svyqsr(~eqIncome, design=des_eusilc, alpha= .20, ncom = nrow(eusilc),
#' comp=TRUE, incvec = eusilc$eqIncome)
#'
#' @export

svyqsr <- function(formula, design, ...) {
    
    UseMethod("svyqsr", design)
    
}

#' @rdname svyqsr
#' @export
svyqsr.survey.design <- function(formula, design, alpha = 0.2, ncom, comp, incvec, 
    ...) {
    inc <- terms.formula(formula)[[2]]
    df <- model.frame(design)
    incvar <- df[[as.character(inc)]]
    w <- weights(design)
    ind <- names(w)
    alpha1 <- alpha
    alpha2 <- 1 - alpha
    quant_inf <- survey::svyquantile(x = formula, design = design, quantiles = alpha1, method = "constant")
    quant_inf <- as.vector(quant_inf)
    quant_sup <- survey::svyquantile(x = formula, design = design, quantiles = alpha2, method = "constant")
    quant_sup <- as.vector(quant_sup)
    tot_var <- sum(incvar * w)
    rich <- (incvar > quant_sup) * incvar
    S80 <- sum(rich * w)
    poor <- (incvar <= quant_inf) * incvar
    S20 <- sum(poor * w)
    qsr <- S80/S20
    # Linearization of S20
    lin_S20 <- isq(formula = formula, design = design, alpha1, type = "inf", h = NULL, 
        ncom = ncom, comp = FALSE, incvec = incvec)$lin
    # Linearization of S80
    lin_S80 <- isq(formula = formula, design = design, alpha2, type = "sup", h = NULL, 
        ncom = ncom, comp = FALSE, incvec = incvec)$lin
    
    # LINEARIZED VARIABLE OF THE SHARE RATIO
    
    lin_qsr <- (S20 * lin_S80 - S80 * lin_S20)/(S20 * S20)
    
    names(lin_qsr) <- ind
    lin_qsr_comp <- complete(lin_qsr, ncom)
    if (comp) 
        lin <- lin_qsr_comp else lin <- lin_qsr
    list(value = qsr, lin = lin_qsr)
}

#' @rdname svyqsr
#' @export
svyqsr.svyrep.design <- function(formula, design, alpha = 0.2, ...) {
    inc <- terms.formula(formula)[[2]]
    df <- model.frame(design)
    incvar <- df[[as.character(inc)]]
    ComputeQsr <- function(x, w, alpha) {
        alpha1 <- alpha
        alpha2 <- 1 - alpha
        quant_inf <- computeQuantiles(x, w, p = alpha1)
        quant_sup <- computeQuantiles(x, w, p = alpha2)
        rich <- (x > quant_sup) * x
        S80 <- sum(rich * w)
        poor <- (x <= quant_inf) * x
        S20 <- sum(poor * w)
        S80/S20
    }
    ws <- weights(design, "sampling")
    rval <- ComputeQsr(incvar, ws, alpha = alpha)
    ww <- weights(design, "analysis")
    qq <- apply(ww, 2, function(wi) ComputeQsr(incvar, w = wi, alpha = alpha))
    variance <- svrVar(qq, design$scale, design$rscales, mse = design$mse, coef = rval)
    list(value = rval, se = sqrt(variance))
}
 

 
 
#' @rdname svyqsr
#' @export
svyqsr.DBIsvydesign <-
	function (x, design, ...) 
	{
		design$variables <- survey:::getvars(x, design$db$connection, design$db$tablename, 
			updates = design$updates, subset = design$subset)
		NextMethod("svyqsr", design)
	}

 