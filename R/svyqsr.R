#' Relative median poverty gap
#'
#' Estimate the difference between the poverty threshold (arpt) and the median of  incomes less than the \code{arpt} relative to the \code{arpt}.
#'
#'
#' @param formula a formula specifying the income variable
#' @param design a design object of class \code{survey.design} or class \code{svyrep.design}
#' of the library survey
#' @param order  income quantile order, usually .5
#' @param percent fraction of the quantile, usually .60
#' @param h bandwidth to estimate the derivative of the cdf function
#' @param ARPR list generated by the function svyarpt
#' @param ncom length of the income vector for the whole sample
#' @param comp logical variable \code{TRUE} if the inearized variable for domains
#' should be completed with zeros
#'
#' @return a list with two components: the indicator estimate \code{value}
#' and the linearized variable \code{lin}.
#'
#' @author Djalma Pessoa and Anthony Damico
#' @seealso \code{\link{arpt}}
#'
#' @references Guillaume Osier (2009). Variance estimation for complex indicators
#'of poverty and inequality. \emph{Journal of the European Survey Research
#' Association}, Vol.3, No.3, pp. 167-195,
#' ISSN 1864-3361, URL \url{http://ojs.ub.uni-konstanz.de/srm/article/view/369}.

#'Jean-Claude Deville (1999). Variance estimation for complex statistics and estimators:
#'linearization and residual techniques. Survey Methodology, 25, 193-203,
#' URL \url{http://www5.statcan.gc.ca/bsolc/olc-cel/olc-cel?lang=eng&catno=12-001-X19990024882}.
#'
#' @keywords survey
#'
#' @examples
#' library(vardpoor)
#' data(eusilc)
#' library(survey)
#' htot <- h_fun(eusilc$eqIncome, eusilc$rb050)
#' des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
#' des_eusilc <- convey_prep( des_eusilc )
#' qsr_eqIncome<- svyqsr(~eqIncome, design=des_eusilc, alpha= .20, ncom = rownames(eusilc),
#' comp=TRUE, incvec = eusilc$eqIncome)
#'
#' @export

svyqsr <- function(formula, design, ...) {

    UseMethod("svyqsr", design)

}

#' @rdname svyqsr
#' @export
svyqsr.survey.design <- function(formula, design, alpha = 0.2, ncom, comp, incvec,
    ...) {

	if( is.null( attr( design , "full_design" ) ) ) stop( "you must run the ?convey_prep function on your linearized survey design object immediately after creating it with the svydesign() function." )

    w <- weights(design)
    ind <- names(w)
    alpha1 <- alpha
    alpha2 <- 1 - alpha
    # Linearization of S20
    S20 <- isq(formula = formula, design = design, alpha1, type = "inf", h = NULL,
      ncom = ncom, comp = FALSE, incvec = incvec)
    # Linearization of S80
    S80 <- isq(formula = formula, design = design, alpha2, type = "sup", h = NULL,
      ncom = ncom, comp = FALSE, incvec = incvec)
    # LINEARIZED VARIABLE OF THE SHARE RATIO
    list_all<- list(S20 = S20, S80 = S80)
    QSR <- contrastinf( quote(S80/S20), list_all)
    lin_qsr <- QSR$lin
    names(lin_qsr) <- ind
    lin_qsr_comp <- complete(lin_qsr, ncom)
    if (comp) lin <- lin_qsr_comp else lin <- lin_qsr
	
	rval <- QSR$value

	# if the class of the full_design attribute is just a TRUE, then the design is already the full design.
	# otherwise, pull the full_design from that attribute.
	if( 'logical' %in% class( attr( design , "full_design" ) ) ) full_design <- design else full_design <- attr( design , "full_design" )

	variance <- ( SE_lin2( lin , full_design ) )^2
 	class(rval) <- "cvystat"
	attr( rval , "var" ) <- variance
	attr( rval , "statistic" ) <- "qsr"
	rval
	
  }

#' @rdname svyqsr
#' @export
svyqsr.svyrep.design <- function(formula, design, alpha = 0.2, ...) {
    inc <- terms.formula(formula)[[2]]
    df <- model.frame(design)
    incvar <- df[[as.character(inc)]]
    ComputeQsr <- function(x, w, alpha) {
        alpha1 <- alpha
        alpha2 <- 1 - alpha
        quant_inf <- computeQuantiles(x, w, p = alpha1)
        quant_sup <- computeQuantiles(x, w, p = alpha2)
        rich <- (x > quant_sup) * x
        S80 <- sum(rich * w)
        poor <- (x <= quant_inf) * x
        S20 <- sum(poor * w)
        S80/S20
    }
    ws <- weights(design, "sampling")
    rval <- ComputeQsr(incvar, ws, alpha = alpha)
    ww <- weights(design, "analysis")
    qq <- apply(ww, 2, function(wi) ComputeQsr(incvar, w = wi, alpha = alpha))
    variance <- svrVar(qq, design$scale, design$rscales, mse = design$mse, coef = rval)

	class(rval)<- "cvystat"
	attr( rval , "var" ) <- variance
	attr( rval , "statistic" ) <- "qsr"
	rval
}




#' @rdname svyqsr
#' @export
svyqsr.DBIsvydesign <-
	function (x, design, ...)
	{
		design$variables <- survey:::getvars(x, design$db$connection, design$db$tablename,
			updates = design$updates, subset = design$subset)
		NextMethod("svyqsr", design)
	}

