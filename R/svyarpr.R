#' At-risk-of-poverty rate
#'
#' Estimate the proportion of persons with income below the
#' at-risk-of-poverty threshold.
#'
#' @param formula a formula specifying the income variable
#' @param design a design object of class \code{survey.design} or class \code{svyrep.design}
#' of the library survey
#' @param order  income quantile order, usually .5
#' @param percent fraction of the quantile, usually .60
#' @param h bandwidth to estimate the derivative of the cdf function
#' @param ARPR list generated by the function svyarpt
#' @param ncom length of the income vector for the whole sample
#' @param comp logical variable \code{TRUE} if the inearized variable for domains
#' should be completed with zeros
#'
#' @return a list with two components: the indicator estimate \code{value}
#' and the linearized variable \code{lin}.
#'
#' @author Djalma Pessoa and Anthony Damico
#' #' @seealso \code{\link{arpt}}
#'
#' @references Guillaume Osier (2009). Variance estimation for complex indicators
#'of poverty and inequality. \emph{Journal of the European Survey Research
#' Association}, Vol.3, No.3, pp. 167-195,
#' ISSN 1864-3361, URL \url{http://ojs.ub.uni-konstanz.de/srm/article/view/369}.

#'Jean-Claude Deville (1999). Variance estimation for complex statistics and estimators:
#'linearization and residual techniques. Survey Methodology, 25, 193-203,
#' URL \url{http://www5.statcan.gc.ca/bsolc/olc-cel/olc-cel?lang=eng&catno=12-001-X19990024882}.
#'
#' @keywords survey
#'
#' @examples
#' library(vardpoor)
#' data(eusilc)
#' library(survey)
#' htot <- h_fun(eusilc$eqIncome, eusilc$rb050)
#' des_eusilc <- svydesign(ids=~db040, weights=~rb050, data=eusilc)
#' arpt_eqIncome<-svyarpt(~eqIncome, design=des_eusilc, .5, .6, h = htot, ncom=nrow(eusilc), comp=TRUE)
#' arpr_eqIncome<- svyarpr(~eqIncome, design=des_eusilc, .5, .6, h = htot,
#' ARPT = arpt_eqIncome, ncom=nrow(eusilc), comp=TRUE)
#'
#' @export
#'
 svyarpr <-function( formula , design , ... ){

  UseMethod( "svyarpr" , design )

}

#' @rdname svyarpr
#' @export
svyarpr.survey.design <- function(formula, design, order = .50, percent =.6, h, ARPT, ncom, ...){
  inc <- terms.formula(formula)[[2]]
  df <- model.frame(design)
  incvar<-df[[as.character(inc)]]
  w <- weights(design)
  ARPT_val <- ARPT$value
  lin_ARPT <- ARPT$lin
  poor <- (incvar < ARPT_val) *1
  design <- update (design, poor = poor)
  ARPRC <- svymean (~poor, design = design)
  ARPRC <- coef (ARPRC)
  lin_ARPR <- icdf(formula = formula, design = design, ARPT_val, ncom=ncom,
  comp=TRUE)$lin + densfun(formula = formula, design = design ,
  ARPT_val, htot=h, fun="F")*lin_ARPT
  list(value = ARPRC, lin = lin_ARPR)
}

#' @rdname svyarpr
#' @export
svyarpr.svyrep.design <- function(formula, design, order = .50, percent =.6, ...){
  inc <- terms.formula(formula)[[2]]
  df <- model.frame(design)
  incvar<-df[[as.character(inc)]]
  ws <- weights(design, "sampling")
  ComputeArpr <- function (x, w, order, percent){
    tresh <-percent*computeQuantiles(x, w, p = order)
 sum((incvar< tresh)*w )/sum(w)
  }
  rval <- ComputeArpr(x=incvar, w=ws, order = order, percent = percent)
 ww <- weights(design, "analysis")
 qq <- apply(ww, 2, function(wi) 0.6*ComputeArpr(incvar, wi, order = order, percent = percent ))
 variance <- svrVar(qq,design$scale,design$rscales, mse = design$mse, coef = rval)
 list(value = rval, se = sqrt(variance))
}
